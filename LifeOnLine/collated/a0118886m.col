//@author: a0118886m



	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\Date.java
	 */


/**
 * This class represents a date with a day, month, year and time from 2010 to 2099.
 */

package lol;

import java.util.Calendar;
import java.util.GregorianCalendar;

public class Date {

	/************ Attributes ***************/
	private int day; // from 1 to 31
	private int month; // from 1 to 12
	private String monthName; // Jan, Feb, ... Dec
	private int year4Digit; // 4 digit year e.g 2013
	private int year2Digit; // 10 to 99 for 2010 to 2099
	private Time time; // Time of the day

	/************ Constructors *************/
	public Date() { // Default value 1 Jan of current year
		setDay(1);
		setMonth(1);
		setMonthName(getMonthName(1));
		setYear4Digit(getCurrentYear());
		setYear2Digit(getCurrentYear() % 100);
		setTime(new Time());
	}

	public Date(int day, int month, int year, Time time) { // e.g 2/3/14 5am or
															// 2/3/2014 5am
		setDay(day);
		setMonth(month);
		setMonthName(getMonthName(month));
		setYear4Digit(getYear4Digit(year));
		setYear2Digit(getYear2Digit(year));
		setTime(time);
	}

	public Date(int day, int month, Time time) { // e.g 6/7 8pm
		setDay(day);
		setMonth(month);
		setMonthName(getMonthName(month));

		int currYear = getCurrentYear();

		// date with day and month in current year
		Date newDate = new Date(day, month, currYear, time);

		// if date is more than 7 days before today, assume the date is in the
		// next year

		if (newDate.isBefore(getTodaysDate())
				&& newDate.getDateDifference(newDate, getTodaysDate()) > Constants.DAYS_OFFSET) {
			setYear4Digit(currYear + 1);
			setYear2Digit((currYear + 1) % 100);
		} else {
			setYear4Digit(currYear);
			setYear2Digit(currYear % 100);
		}

		setTime(time);
	}

	public Date(int day, int month, int year) { // e.g 2/3/14 or 2/3/2014
		setDay(day);
		setMonth(month);
		setMonthName(getMonthName(month));
		setYear4Digit(getYear4Digit(year));
		setYear2Digit(getYear2Digit(year));
		setTime(new Time());
	}

	public Date(int day, int month) { // e.g 6/7
		setDay(day);
		setMonth(month);
		setMonthName(getMonthName(month));

		int currYear = getCurrentYear();

		// date with day and month in current year
		Date newDate = new Date(day, month, currYear);

		// if date is more than 7 days before today, assume the date is in the
		// next year

		if (newDate.isBefore(getTodaysDate())
				&& newDate.getDateDifference(newDate, getTodaysDate()) > Constants.DAYS_OFFSET) {
			setYear4Digit(currYear + 1);
			setYear2Digit((currYear + 1) % 100);
		} else {
			setYear4Digit(currYear);
			setYear2Digit(currYear % 100);
		}

		setTime(new Time());
	}

	/************ Accessors *************/
	public int getDay() {
		return day;
	}

	public int getMonth() {
		return month;
	}

	public String getMonthName() {
		return monthName;
	}

	public int getYear4Digit() {
		return year4Digit;
	}

	public int getYear2Digit() {
		return year2Digit;
	}

	public Time getTime() {
		return time;
	}

	public int getCurrentYear() {
		return getTodaysDate().getYear4Digit();
	}

	public int getCurrentMonth() {
		return getTodaysDate().getMonth();
	}

	public int getCurrentDay() {
		return getTodaysDate().getDay();
	}

	/************ Mutators *************/
	public void setDay(int day) {
		this.day = day;
	}

	public void setMonth(int month) {
		this.month = month;
	}

	public void setMonthName(String monthName) {
		this.monthName = monthName;
	}

	public void setYear4Digit(int year) {
		this.year4Digit = year;
	}

	public void setYear2Digit(int year) {
		this.year2Digit = year;
	}

	public void setTime(Time time) {
		this.time = time;
	}

	/********** Overriding methods ***********/
	public String toString() { // e.g. 7 Dec 2015
		return getDay() + Constants.SPACE + getMonthName() + Constants.SPACE
				+ getYear4Digit();
	}

	public String toString2() { // e.g. 7/12/2015
		return getDay() + Constants.SEPARATOR_SLASH + getMonth()
				+ Constants.SEPARATOR_SLASH + getYear4Digit();
	}

	public boolean equals(Object obj) {
		if (obj instanceof Date) {
			Date other = (Date) obj;
			return other.getDay() == this.getDay()
					&& other.getMonth() == this.getMonth()
					&& other.getYear4Digit() == this.getYear4Digit()
					&& other.getTime().equals(this.getTime());
		} else {
			return false;
		}
	}

	public static boolean equalDate(Date date1, Date date2) {
		if (date1 == null && date2 != null) {
			return false;
		} else if (date1 != null && date2 == null) {
			return false;
		} else if (date1 == null && date2 == null) {
			return true;
		} else {
			return date1.getDay() == date2.getDay()
					&& date1.getMonth() == date2.getMonth()
					&& date1.getYear4Digit() == date2.getYear4Digit();
		}
	}

	/*********** Comparison methods ***********/

	/**
	 * Checks whether a date is earlier than the parameter object
	 * 
	 * @param other
	 *            Date to be compared with
	 * @return true if "this" is earlier than "other", else false
	 */
	public boolean isBefore(Date other) {
		if (this.getYear4Digit() < other.getYear4Digit()) { // year is smaller
			return true;
		} else if (this.getYear4Digit() > other.getYear4Digit()) { // year is
																	// greater
			return false;
		} else { // same year
			if (this.getMonth() < other.getMonth()) { // month is smaller
				return true;
			} else if (this.getMonth() > other.getMonth()) { // month is greater
				return false;
			} else { // same month
				if (this.getDay() < other.getDay()) { // day is smaller
					return true;
				} else if (this.getDay() > other.getDay()) { // day is greater
					return false;
				} else { // same day
					if (this.getTime().isBefore(other.getTime())) { // time is
																	// smaller
						return true;
					} else { // time is greater or equal
						return false;
					}
				}
			}
		}
	}

	/**
	 * Checks whether a date is later than the parameter object
	 * 
	 * @param other
	 *            Date to be compared with
	 * @return true if "this" is later than "other", else false
	 */
	public boolean isAfter(Date other) {
		return !equals(other) && !isBefore(other);
	}

	/************ Other methods *************/

	/**
	 * Returns first 3 letters of the month
	 * 
	 * @param month
	 *            number of the month
	 * @return month name
	 */
	public String getMonthName(int month) {
		if (month >= 1 && month <= 12) {
			return Constants.MONTHS_1ST_LETTER_CAPS_SHORT[month - 1];
		} else {
			return Constants.MONTHS_1ST_LETTER_CAPS_SHORT[0];
		}
	}

	/**
	 * Returns the entire name of the month
	 * 
	 * @param month
	 *            number of the month
	 * @return month name
	 */
	public String getMonthNameLong(int month) {
		if (month >= 1 && month <= 12) {
			return Constants.MONTHS_1ST_LETTER_CAPS_LONG[month - 1];
		} else {
			return Constants.MONTHS_1ST_LETTER_CAPS_LONG[0];
		}
	}

	/**
	 * Returns 4-digit year from 2010 to 2099
	 * 
	 * @param year
	 *            2-digit or 4-digit year
	 * @return 4-digit year
	 */
	private int getYear4Digit(int year) {
		if (year <= Constants.LIMIT_MAX_2DIGIT_YEAR) {
			return Constants.YEAR_2000 + year;
		} else {
			return year;
		}
	}

	/**
	 * Returns 2-digit year from 2010 to 2099
	 * 
	 * @param year
	 *            2-digit or 4-digit year
	 * @return 10 to 99 - 2-digit year
	 */
	private int getYear2Digit(int year) {
		if (year <= Constants.LIMIT_MAX_2DIGIT_YEAR) {
			return year;
		} else {
			return year - Constants.YEAR_2000;
		}
	}

	/**
	 * Returns today's date
	 * 
	 * @return Date object containing today's date
	 */
	public Date getTodaysDate() {
		Calendar rightNow = Calendar.getInstance(); // Get the current date
		return new Date(rightNow.get(Calendar.DATE),
				rightNow.get(Calendar.MONTH) + 1, rightNow.get(Calendar.YEAR));
	}

	/**
	 * Returns number of days between 2 dates
	 * 
	 * @param earlierDate
	 *            earlier date
	 * @param laterDate
	 *            later date
	 * @return number of days laterDate is ahead of earlierDate. If earlierDate
	 *         is after laterDate, returns a negative number
	 */
	public int getDateDifference(Date earlierDate, Date laterDate) {
		Calendar earlier = new GregorianCalendar();
		Calendar later = new GregorianCalendar();

		earlier.set(earlierDate.getYear4Digit(), earlierDate.getMonth() - 1,
				earlierDate.getDay());
		later.set(laterDate.getYear4Digit(), laterDate.getMonth() - 1,
				laterDate.getDay());

		return (int) ((later.getTime().getTime() - earlier.getTime().getTime()) / Constants.MILLISECONDS_IN_A_DAY);
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\Date.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\DateTest.java
	 */


package lol;

import static org.junit.Assert.*;

import org.junit.Test;

public class DateTest {

	@Test
	public void testGetDay() {
		Date d = new Date(4, 2, new Time(10, "am"));
		assertEquals(4, d.getDay());
	}

	@Test
	public void testGetMonth() {
		Date d = new Date(4, 2, new Time(10, "am"));
		assertEquals(2, d.getMonth());
	}

	@Test
	public void testGetMonthName() {
		Date d = new Date(4, 2, new Time(10, "am"));
		assertEquals("Feb", d.getMonthName());
	}

	@Test
	public void testGetYear4Digit() {
		Date d = new Date(4, 2, new Time(10, "am"));
		assertEquals(2015, d.getYear4Digit());
		Date d1 = new Date(4, 12, new Time(10, "am"));
		assertEquals(2014, d1.getYear4Digit());
	}

	@Test
	public void testGetYear2Digit() {
		Date d = new Date(4, 2, new Time(10, "am"));
		assertEquals(15, d.getYear2Digit());
		Date d1 = new Date(4, 12, new Time(10, "am"));
		assertEquals(14, d1.getYear2Digit());
	}

	@Test
	public void testGetTime() {
		Date d = new Date(4, 2, new Time(10, "am"));
		assertEquals(new Time("1000"), d.getTime());
	}
	
	@Test
	public void testGetCurrentYear() {
		Date d = new Date();
		assertEquals(2014, d.getCurrentYear());
	}

	@Test
	public void testToString() {
		Date d1 = new Date(4, 2, new Time(10, "am"));
		Date d2 = new Date(5, 6, 15, new Time(11, "am"));
		Date d3 = new Date(18, 8, 2013, new Time(10, "am"));
		Date d4 = new Date(18, 11, 14, new Time(10, "am"));
		Date d5 = new Date(19, 10);
		Date d6 = new Date(11, 10);
		assertEquals("11 Oct 2015", d6.toString());
		assertEquals("19 Oct 2015", d5.toString());
		assertEquals("18 Nov 2014", d4.toString());
		assertEquals("18 Aug 2013", d3.toString());
		assertEquals("5 Jun 2015", d2.toString());
		assertEquals("4 Feb 2015", d1.toString());
	}

	@Test
	public void testEqualsObject() {
		Date d1 = new Date(4, 2, new Time(10, "am"));
		Date d2 = new Date(4, 2, 15, new Time("1000"));
		Date d3 = new Date(18, 8, 2013, new Time(10, "am"));
		assertTrue(d1.equals(d2));
		assertFalse(d2.equals(d3));
	}

	@Test
	public void testGetMonthNameInt() {
		Date d = new Date();
		assertEquals("Mar", d.getMonthName(3));
	}

	@Test
	public void testIsBefore() {
		Date d1 = new Date(4, 2, new Time(10, "am"));
		Date d2 = new Date(4, 2, 14, new Time("1000"));
		Date d3 = new Date(18, 8, 2013, new Time(10, "am"));
		assertTrue(d3.isBefore(d2));
		assertFalse(d1.isBefore(d2));
	}

	@Test
	public void testIsAfter() {
		Date d1 = new Date(4, 2, new Time(10, "am"));
		Date d2 = new Date(4, 2, 14, new Time("1000"));
		Date d3 = new Date(18, 8, 2013, new Time(10, "am"));
		assertTrue(d2.isAfter(d3));
		assertFalse(d2.isAfter(d1));
	}

	@Test
	public void testGetDateDifference() {
		Date d = new Date();
		Date d1 = new Date(20, 10, 2014);
		Date d2 = new Date(23, 10, 2014);
		Date d3 = new Date(1, 9, 2014);
		assertEquals(3, d.getDateDifference(d1, d2));
		assertEquals(52, d.getDateDifference(d3, d2));
		assertEquals(-3, d1.getDateDifference(d2, d1));
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\DateTest.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\Task.java
	 */

	/************ Constructors *************/
	public Task(String description, String location, Date dueDate) {
		setDescription(description);
		setLocation(location);
		setDueDate(dueDate);
		setEndDate(null);
		setStartTime(null);
		setEndTime(null);
		setIsDone(false);
		setIsOverdue(false);
		setAlerted(false);
		setIsJustAdded(false);
	}

	public Task(String description, String location, Date dueDate,
			Time startTime, Time endTime) {
		setDescription(description);
		setLocation(location);
		setDueDate(dueDate);
		setEndDate(null);
		setStartTime(startTime);
		setEndTime(endTime);
		setIsDone(false);
		setIsOverdue(false);
		setAlerted(false);
		setIsJustAdded(false);
	}
	
	public Task(String description, String location, Date dueDate, Date endDate) {
		setDescription(description);
		setLocation(location);
		setDueDate(dueDate);
		setEndDate(endDate);
		setStartTime(null);
		setEndTime(null);
		setIsDone(false);
		setIsOverdue(false);
		setAlerted(false);
		setIsJustAdded(false);
	}

	public Task(String description, String location, Date dueDate, Date endDate, 
			Time startTime, Time endTime) {
		setDescription(description);
		setLocation(location);
		setDueDate(dueDate);
		setEndDate(endDate);
		setStartTime(startTime);
		setEndTime(endTime);
		setIsDone(false);
		setIsOverdue(false);
		setAlerted(false);
		setIsJustAdded(false);
	}

	/************ Accessors *************/
	public String getTaskDescription() {
		return description;
	}

	public String getTaskLocation() {
		return location;
	}

	public Date getTaskDueDate() {
		return dueDate;
	}
	
	public Date getEndDate() {
		return endDate;
	}

	public Time getStartTime() {
		return startTime;
	}

	public Time getEndTime() {
		return endTime;
	}

	public boolean getIsDone() {
		return isDone;
	}

	public boolean getIsOverdue() {
		return isOverdue;
	}
	
	public boolean getAlerted() {
		return alerted;
	}
	
	public boolean getIsJustAdded(){
		return isJustAdded;
	}

	/************ Mutators *************/
	public void setDescription(String description) {
		this.description = description;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public void setDueDate(Date date) {
		this.dueDate = date;
	}

	public void setEndDate(Date endDate) {
		this.endDate = endDate;
	}
	
	public void setStartTime(Time startTime) {
		this.startTime = startTime;
	}

	public void setEndTime(Time endTime) {
		this.endTime = endTime;
	}

	public void setIsDone(boolean isDone) {
		this.isDone = isDone;
	}

	public void setIsOverdue(boolean isOverdue) {
		this.isOverdue = isOverdue;
	}
	
	public void setAlerted(boolean alerted) {
		this.alerted = alerted;
	}

	public void setIsJustAdded(boolean isJustAdded){
		this.isJustAdded = isJustAdded;
	}
	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\Task.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\Task.java
	 */

	/********** Overriding methods ***********/
	public String toString() {
		return getTaskDescription();
	}

	public boolean equals(Object obj) {
		if (obj instanceof Task) {
			Task other = (Task) obj;
			boolean isDateSame = false;
			boolean isEndDateSame = false;
			boolean isStartTimeSame = false;
			boolean isEndTimeSame = false;
			boolean isDescSame = false;
			boolean isLocationSame = false;

			if ((other.getStartTime() == null && this.getStartTime() == null)
					|| ((other.getStartTime() != null && this.getStartTime() != null) && (other
							.getStartTime().equals(this.getStartTime())))) {
				isStartTimeSame = true;
			}

			if ((other.getEndTime() == null && this.getEndTime() == null)
					|| ((other.getEndTime() != null && this.getEndTime() != null) && (other
							.getEndTime().equals(this.getEndTime())))) {
				isEndTimeSame = true;
			}

			if ((other.getTaskDueDate() == null && this.getTaskDueDate() == null)
					|| ((other.getTaskDueDate() != null && this
							.getTaskDueDate() != null) && (other
							.getTaskDueDate().equals(this.getTaskDueDate())))) {
				isDateSame = true;
			}
			
			if ((other.getEndDate() == null && this.getEndDate() == null)
					|| ((other.getEndDate() != null && this.getEndDate() != null) && (other
							.getEndDate().equals(this.getEndDate())))) {
				isEndDateSame = true;
			}

			if ((other.getTaskLocation() == null && this.getTaskLocation() == null)
					|| ((other.getTaskLocation() != null && this
							.getTaskLocation() != null) && (other
							.getTaskLocation().equals(this.getTaskLocation())))) {
				isLocationSame = true;
			}

			if ((other.getTaskDescription() == null && this
					.getTaskDescription() == null)
					|| ((other.getTaskDescription() != null && this
							.getTaskDescription() != null) && (other
							.getTaskDescription().equals(this
							.getTaskDescription())))) {
				isDescSame = true;
			}

			return isDateSame && isEndDateSame && isDescSame && isLocationSame
					&& isStartTimeSame && isEndTimeSame;
		} else {
			return false;
		}
	}

	public int compareTo(Task that) {
		final int BEFORE = -1;
		final int EQUAL = 0;
		final int AFTER = 1;

		// Task with date will be higher priority than tasks without date
		if ((that.getTaskDueDate() == null) && (this.getTaskDueDate() != null)) {
			return BEFORE;
		}

		// Task without date will be lower priority than tasks with date
		else if ((this.getTaskDueDate() == null)
				&& (that.getTaskDueDate() != null)) {
			return AFTER;
		}

		// If all are tasks without date, they prioritize order in which user
		// entered
		else if ((this.getTaskDueDate() == null)
				&& (that.getTaskDueDate() == null)) {
			return AFTER;
		}

		else if ((that.getTaskDueDate() != null)
				&& (this.getTaskDueDate() != null)
				&& (this.getStartTime() != null)
				&& (that.getStartTime() != null) && (this.getEndTime() == null)
				&& (that.getEndTime() == null)
				&& this.getStartTime().equals(that.getStartTime())) {
			return EQUAL;
		}

		else if ((that.getTaskDueDate() != null)
				&& (this.getTaskDueDate() != null)
				&& (this.getStartTime() != null)
				&& (that.getStartTime() != null) && (this.getEndTime() == null)
				&& (that.getEndTime() != null)
				&& this.getStartTime().equals(that.getStartTime())) {
			return BEFORE;
		}

		else if ((that.getTaskDueDate() != null)
				&& (this.getTaskDueDate() != null)
				&& (this.getStartTime() != null)
				&& (that.getStartTime() != null) && (this.getEndTime() != null)
				&& (that.getEndTime() == null)
				&& this.getStartTime().equals(that.getStartTime())) {
			return AFTER;
		}

		// same date, null time -> equal priority
		else if (((this.getTaskDueDate() != null) && (that.getTaskDueDate() != null))
				&& (this.getTaskDueDate().equals(that.getTaskDueDate()))
				&& ((this.getStartTime() == null) && (that.getStartTime() == null))) {

			return EQUAL;
		}

		// same date, null time has lower priority
		else if (((this.getTaskDueDate() != null) && (that.getTaskDueDate() != null))
				&& (this.getTaskDueDate().equals(that.getTaskDueDate()))
				&& ((this.getStartTime() == null) && (that.getStartTime() != null))) {

			return AFTER;
		}

		// same date, non-null time has higher priorty
		else if (((this.getTaskDueDate() != null) && (that.getTaskDueDate() != null))
				&& (this.getTaskDueDate().equals(that.getTaskDueDate()))
				&& ((this.getStartTime() != null) && (that.getStartTime() == null))) {

			return BEFORE;
		}

		// non-null Date that occurs before has higher priority
		else if (this.isBefore(that)) {
			return BEFORE;
		}

		// non-null Date that occurs after has lower priority
		else if (this.isAfter(that)) {
			return AFTER;
		}
		
		// if one date has a date range then it has lower priority
		else if (this.getEndDate() == null && that.getEndDate() != null) {
			return BEFORE;
		}
		
		else if (this.getEndDate() != null && that.getEndDate() == null) {
			return AFTER;
		}
		
		// if both have end date then the one with earlier end date has higher priority
		else if (this.getEndDate().isBefore(that.getEndDate())) {
			return BEFORE;
		}
		
		else if (this.getEndDate().isAfter(that.getEndDate())) {
			return AFTER;
		}

		// both have same end date
		else {
			return EQUAL;
		}
	}

	/********** Comparison methods ***********/
	public boolean isBefore(Task other) {
		return this.getTaskDueDate().isBefore(other.getTaskDueDate())
				|| (this.getTaskDueDate().equals(other.getTaskDueDate()) && (this
						.getStartTime().isBefore(other.getStartTime())))
				|| (this.getTaskDueDate().equals(other.getTaskDueDate())
						&& (this.getStartTime().equals(other.getStartTime())) && (this
							.getEndTime().isBefore(other.getEndTime()))
							
							|| (this.getTaskDueDate().equals(other.getTaskDueDate()) &&
									this.getStartTime().equals(other.getStartTime()) &&
									this.getEndTime().equals(other.getEndTime()) &&
									this.getEndDate().isBefore(other.getEndDate())));
	}

	public boolean isAfter(Task other) {
		return this.getTaskDueDate().isAfter(other.getTaskDueDate())
				|| (this.getTaskDueDate().equals(other.getTaskDueDate()) && (this
						.getStartTime().isAfter(other.getStartTime())))
				|| (this.getTaskDueDate().equals(other.getTaskDueDate())
						&& (this.getStartTime().equals(other.getStartTime())) && (this
							.getEndTime().isAfter(other.getEndTime()))
							
							|| (this.getTaskDueDate().equals(other.getTaskDueDate()) &&
									this.getStartTime().equals(other.getStartTime()) &&
									this.getEndTime().equals(other.getEndTime()) &&
									this.getEndDate().isAfter(other.getEndDate())));
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\Task.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\Time.java
	 */


/**
 * This class represents a time of the day.
 */
package lol;

import java.text.DecimalFormat;

public class Time {

	/************ Attributes ***************/
	private int hour; // from 1 to 12 when initialized
	private int min; // from 0 to 59 when initialized
	private String ampm; // am or pm
	private String format24hr; // 4 digit 24hr format

	/************ Constructors *************/
	public Time() { // Uninitialized time
		setHour(Constants.LIMIT_MIN_HR - 1);
		setMin(Constants.LIMIT_MIN_MINUTE);
		setAmpm(Constants.STRING_AM);
		setFormat24hr(Constants.STRING_2400); // Time does not exist
	}

	public Time(int hour, int min, String ampm) { // e.g. 3.40pm
		setHour(hour);
		setMin(min);
		setAmpm(ampm);
		setFormat24hr(convertTo24hr(hour, min, ampm));
	}

	public Time(int hour, String ampm) { // e.g. 2am
		setHour(hour);
		setMin(Constants.LIMIT_MIN_MINUTE);
		setAmpm(ampm);
		setFormat24hr(convertTo24hr(this.hour, this.min, this.ampm));
		;
	}

	public Time(String format24hr) { // e.g. 2359
		setHour(getHour(format24hr));
		setMin(getMin(format24hr));
		setAmpm(getAmpm(format24hr));
		setFormat24hr(format24hr);
	}

	/************ Accessors *************/
	public int getHour() {
		return hour;
	}

	public int getMin() {
		return min;
	}

	public String getAmpm() {
		return ampm;
	}

	public String getFormat24hr() {
		return format24hr;
	}

	/************ Mutators *************/
	public void setHour(int hour) {
		this.hour = hour;
	}

	public void setMin(int min) {
		this.min = min;
	}

	public void setAmpm(String ampm) {
		this.ampm = ampm;
	}

	public void setFormat24hr(String format24hr) {
		this.format24hr = format24hr;
	}

	/********** Overriding methods ***********/
	public String toString() { // e.g. 1.43pm
		DecimalFormat df = new DecimalFormat(Constants.FORMAT_2_DIGITS);
		return getHour() + Constants.DOT + df.format(getMin())
				+ getAmpm();
	}

	public boolean equals(Object obj) {
		if (obj instanceof Time) {
			Time other = (Time) obj;
			return other.getFormat24hr().equals(this.getFormat24hr());
		} else {
			return false;
		}
	}

	/*********** Comparison methods ***********/

	/**
	 * Checks whether a time is earlier than the parameter object
	 * 
	 * @param other
	 *            Time to be compared with
	 * @return true if "this" is earlier than "other", else false
	 */
	public boolean isBefore(Time other) {
		return Integer.parseInt(this.format24hr) < Integer
				.parseInt(other.format24hr);
	}

	/**
	 * Checks whether a time is later than the parameter object
	 * 
	 * @param other
	 *            Time to be compared with
	 * @return true if "this" is later than "other", else false
	 */
	public boolean isAfter(Time other) {
		return Integer.parseInt(this.format24hr) > Integer
				.parseInt(other.format24hr);
	}

	/************ Conversion methods *************/

	/**
	 * Convert a time from 12-hour format to 4-digit 24-format Example: 5.02pm
	 * to "1702"
	 * 
	 * @param hour
	 *            hour from 1 to 12
	 * @param min
	 *            minute from 0 to 59
	 * @param ampm
	 *            am or pm
	 * @return 4-digit 24-hour format string
	 */
	public String convertTo24hr(int hour, int min, String ampm) {
		DecimalFormat df = new DecimalFormat(Constants.FORMAT_2_DIGITS); // 2
																			// digits

		if (hour == Constants.LIMIT_MAX_12HR) {
			hour = Constants.LIMIT_MIN_HR - 1;
		}

		switch (ampm) {
		case Constants.STRING_AM:
			return df.format(hour) + df.format(min);

		case Constants.STRING_PM:
			return df.format(hour + Constants.LIMIT_MAX_12HR) + df.format(min);

		default:
			return Constants.STRING_0000;
		}
	}

	/**
	 * Given a 24-hour format time, returns the hour in 12-hour format Example:
	 * "2250" returns 10
	 * 
	 * @param format24hr
	 *            4-digit 24-hour format string
	 * @return hour in 12-hour format
	 */
	public int getHour(String format24hr) {
		// first 2 digits
		int hr = Integer.parseInt(format24hr.substring(0, 2));

		if (hr == Constants.LIMIT_MIN_HR - 1) {
			hr = Constants.LIMIT_MAX_12HR;
		} else if (hr > Constants.LIMIT_MAX_12HR) {
			hr -= Constants.LIMIT_MAX_12HR;
		}
		return hr;
	}

	/**
	 * Given a 24-hour format time, returns the minute Example: "2250" returns
	 * 50
	 * 
	 * @param format24hr
	 *            4-digit 24-hour format string
	 * @return minute
	 */
	public int getMin(String format24hr) {
		return Integer.parseInt(format24hr.substring(2));
	}

	/**
	 * Given a 24-hour format time, returns whether the time is am or pm in
	 * 12-hour format Example: "2250" returns pm, "0800" returns am
	 * 
	 * @param format24hr
	 *            4-digit 24-hour format string
	 * @return am or pm in 12-hour format
	 */
	public String getAmpm(String format24hr) {
		int hr = Integer.parseInt(format24hr.substring(0, 2));
		return (hr < 12) ? Constants.STRING_AM : Constants.STRING_PM;
	}

}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\Time.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\TimeTest.java
	 */


package lol;

import static org.junit.Assert.*;

import org.junit.Test;

public class TimeTest {

	@Test
	public void testConvertTo24hr() {
		Time t = new Time();
		assertEquals("1130", t.convertTo24hr(11, 30, "am"));
		assertEquals("0530", t.convertTo24hr(5, 30, "am"));
		assertEquals("0050", t.convertTo24hr(12, 50, "am"));
		assertEquals("0800", t.convertTo24hr(8, 0, "am"));
		assertEquals("1200", t.convertTo24hr(12, 0, "pm"));
		assertEquals("1410", t.convertTo24hr(2, 10, "pm"));
		
		/* This is a boundary case for a 24-hour time format */
		assertEquals("2359", t.convertTo24hr(11, 59, "pm"));
	}

	@Test
	public void testGetHour() {
		Time t = new Time();
		assertEquals(11, t.getHour("1130"));
		assertEquals(5, t.getHour("0530"));
		assertEquals(12, t.getHour("0050"));
		assertEquals(8, t.getHour("0800"));
		assertEquals(12, t.getHour("1200"));
		assertEquals(2, t.getHour("1410"));
		assertEquals(11, t.getHour("2359"));
	}

	@Test
	public void testGetMin() {
		Time t = new Time();
		assertEquals(30, t.getMin("1130"));
		assertEquals(6, t.getMin("0506"));
		assertEquals(50, t.getMin("0050"));
		assertEquals(0, t.getMin("0800"));
		assertEquals(0, t.getMin("1200"));
		assertEquals(10, t.getMin("1410"));
		assertEquals(59, t.getMin("2359"));
	}

	@Test
	public void testGetAmpm() {
		Time t = new Time();
		assertEquals("am", t.getAmpm("1130"));
		assertEquals("am", t.getAmpm("0530"));
		assertEquals("am", t.getAmpm("0050"));
		assertEquals("am", t.getAmpm("0800"));
		assertEquals("pm", t.getAmpm("1200"));
		assertEquals("pm", t.getAmpm("1410"));
		assertEquals("pm", t.getAmpm("2359"));
	}

	@Test
	public void testToString() {
		Time t = new Time("1342");
		assertEquals("1.42pm", t.toString());
	}

	@Test
	public void testEquals() {
		Time t1 = new Time(12, 00, "pm");
		Time t2 = new Time(12, "pm");
		Time t3 = new Time();
		assertTrue(t1.equals(t2));
		assertFalse(t2.equals(t3));
	}

	@Test
	public void testIsBefore() {
		Time t1 = new Time(11, 30, "am");
		Time t2 = new Time(12, "pm");
		Time t3 = new Time(2, 45, "am");
		assertTrue(t1.isBefore(t2));
		assertTrue(t3.isBefore(t1));
	}

	@Test
	public void testIsAfter() {
		Time t1 = new Time(11, 30, "am");
		Time t2 = new Time(12, "pm");
		Time t3 = new Time(2, 45, "am");
		assertTrue(t1.isAfter(t3));
		assertTrue(t2.isAfter(t1));
	}

}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\lol\TimeTest.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\DateParser.java
	 */


/**
 * This class parses a string containing a date or day of the week.
 * The following formats of date are allowed: (not case-sensitive)
 * 
 * 30/9/2014
 * 30/9/14 
 * 30 September 2014 
 * 30 Sep 2014 
 * 30 September 14 
 * 30 Sep 14 
 * 30/9 
 * 30 September
 * 30 Sep
 * 
 * Day of the week: Monday, Mon, Sunday, sun, etc.
 * Today, tomorrow, tmr, tmw, tmrw
 * 
 * Date ranges:
 * 31 october- 5 November
 * 31 oct 2014 to 5 Nov 2014
 * 31/10-5/11
 * Monday-Wed
 * tmr-sun
 * 4-9/12
 * 4-9 Dec
 * 4 to 9 December 2015
 * 
 */

package parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lol.Constants;
import lol.Date;

public class DateParser {
	/************* Attributes ***************/
	private String userInput;
	private String dateKeyword; // keyword preceding date - on, by, from or no
								// keyword

	/************* Constructors ***************/
	public DateParser() {
		this("");
	}

	public DateParser(String userInput) {
		setUserInput(userInput);
		setDateKeyword("");
	}

	/************* Accessors ***************/
	public String getUserInput() {
		return userInput;
	}

	public String getDateKeyword() {
		return dateKeyword;
	}

	/************* Mutators ***************/
	public void setUserInput(String userInput) {
		this.userInput = userInput.toLowerCase();
	}

	public void setDateKeyword(String dateKeyword) {
		this.dateKeyword = dateKeyword.toLowerCase();
	}

	/************* Other methods ***************/

	/**
	 * Returns the due date of task in userInput
	 * 
	 * @return due date of a task in userInput if it exists, else returns null
	 */
	public Date getDueDate() {
		cleanUp();
		String userInput = getUserInput();

		// on
		Pattern pOn = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_ON]);
		Matcher mOn = pOn.matcher(getUserInput());

		while (mOn.find()) {
			String parameter = getParameterStartingAtIndex(mOn.end());
			if (isValidDateFormat(parameter)) {
				setDateKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_ON]);

				if (isDateRange(parameter)) {
					return createDatesFromRange(parameter)[Constants.INDEX_START_DATE];
				} else {
					return createDate(parameter);
				}
			}
		}

		// by
		Pattern pBy = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_BY]);
		Matcher mBy = pBy.matcher(getUserInput());

		while (mBy.find()) {
			String parameter = getParameterStartingAtIndex(mBy.end());
			if (isValidDateFormat(parameter)) {
				setDateKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_BY]);

				if (isDateRange(parameter)) {
					return createDatesFromRange(parameter)[Constants.INDEX_START_DATE];
				} else {
					return createDate(parameter);
				}
			}
		}

		// from
		Pattern pFrom = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_FROM]);
		Matcher mFrom = pFrom.matcher(userInput);

		while (mFrom.find()) {
			String parameter = getParameterStartingAtIndex(mFrom.end());

			if (isDateRange(parameter)) {
				setDateKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_FROM]);
				return createDatesFromRange(parameter)[Constants.INDEX_START_DATE];
			}
		}

		// no keyword
		String temp = getUserInput();
		String[] words = temp.split(Constants.SPACE);

		for (int i = 0; i < words.length; i++) {
			String word = words[i];
			/*
			 * find next 4 words because date and time formats (excluding date
			 * range) can have at most 5 words
			 */
			String[] nextWords = getNext4Words(words, i);

			if (isValidDay(word)
					&& !nextWords[Constants.INDEX_SEPARATOR]
							.equalsIgnoreCase(Constants.SEPARATOR_TO)
					&& !nextWords[Constants.INDEX_SEPARATOR]
							.equals(Constants.SEPARATOR_DASH)) {
				return createDate(word);
			}

			/* check for date range */
			// 1 word - 24-26/11
			if (isDateRange(word)) {
				return createDatesFromRange(word)[Constants.INDEX_START_DATE];
			}
			// 2 words - 24-26 nov
			if (isDateRange(word + " " + nextWords[Constants.INDEX_2ND_WORD])) {
				return createDatesFromRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD])[Constants.INDEX_START_DATE];
			}
			// 3 words - sun - tue, 24/11 to 26/11
			if (isDateRange(word + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD])) {
				return createDatesFromRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD])[Constants.INDEX_START_DATE];
			}
			// 4 words - 24 to 29 Nov
			if (isDateRange(word + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_4TH_WORD])) {
				return createDatesFromRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD])[Constants.INDEX_START_DATE];
			}
			// 5 words - 24 Nov to 26 Nov
			if (isDateRange(word + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_5TH_WORD])) {
				return createDatesFromRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_5TH_WORD])[Constants.INDEX_START_DATE];
			}

			// more than 5 words
			if (i + Constants.INDEX_4TH_WORD < words.length) {
				// 4th word to 7th word
				String[] words4to7 = getNext4Words(words, i
						+ Constants.INDEX_4TH_WORD);

				// 6 words - 24 nov 14 to 26 nov
				if (isDateRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_5TH_WORD] + Constants.SPACE
						+ words4to7[Constants.INDEX_4TH_WORD])) {
					return createDatesFromRange(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_4TH_WORD])[Constants.INDEX_START_DATE];
				}

				// 7 words - 30 dec 2014 to 2 jan 2015
				if (isDateRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_5TH_WORD] + Constants.SPACE
						+ words4to7[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ words4to7[Constants.INDEX_5TH_WORD])) {
					return createDatesFromRange(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_5TH_WORD])[Constants.INDEX_START_DATE];
				}
			}

			// no date range starting from this word
			if (hasDate(word, nextWords)) {
				Pattern p = Pattern.compile(Constants.REGEX_WORD_START + word
						+ Constants.REGEX_WORD_END_SPACES_WORD_START
						+ nextWords[Constants.INDEX_2ND_WORD]
						+ Constants.REGEX_WORD_END);
				Matcher m = p.matcher(temp);

				if (m.find()) {
					String parameter = getParameterStartingAtIndex(m.start());
					return createDate(parameter);
				}
			}
		}
		return null;
	}

	/**
	 * Returns the end date of task in userInput
	 * 
	 * @return end date of a task in userInput if it exists, else returns null
	 */
	public Date getEndDate() {
		cleanUp();

		// on
		Pattern pOn = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_ON]);
		Matcher mOn = pOn.matcher(getUserInput());

		while (mOn.find()) {
			String parameter = getParameterStartingAtIndex(mOn.end());
			if (isDateRange(parameter)) {
				setDateKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_ON]);
				return createDatesFromRange(parameter)[Constants.INDEX_END_DATE];
			}
		}

		// by
		Pattern pBy = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_BY]);
		Matcher mBy = pBy.matcher(getUserInput());

		while (mBy.find()) {
			String parameter = getParameterStartingAtIndex(mBy.end());
			if (isDateRange(parameter)) {
				setDateKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_BY]);
				return createDatesFromRange(parameter)[Constants.INDEX_END_DATE];
			}
		}

		// from
		Pattern pFrom = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_FROM]);
		Matcher mFrom = pFrom.matcher(getUserInput());

		while (mFrom.find()) {
			String parameter = getParameterStartingAtIndex(mFrom.end());
			if (isDateRange(parameter)) {
				setDateKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_FROM]);
				return createDatesFromRange(parameter)[Constants.INDEX_END_DATE];
			}
		}

		// no keyword
		String temp = getUserInput();
		String[] words = temp.split(Constants.SPACE);

		for (int i = 0; i < words.length; i++) {
			String word = words[i];
			/*
			 * find next 4 words because date and time formats (excluding date
			 * range) can have at most 5 words
			 */
			String[] nextWords = getNext4Words(words, i);

			/* check for date range */
			// 1 word - 24-26/11
			if (isDateRange(word)) {
				return createDatesFromRange(word)[Constants.INDEX_END_DATE];
			}
			// 2 words - 24-26 nov
			if (isDateRange(word + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD])) {
				return createDatesFromRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD])[Constants.INDEX_END_DATE];
			}
			// 3 words - sun - tue, 24/11 to 26/11
			if (isDateRange(word + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD])) {
				return createDatesFromRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD])[Constants.INDEX_END_DATE];
			}
			// 4 words - 24 to 29 Nov
			if (isDateRange(word + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_4TH_WORD])) {
				return createDatesFromRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD])[Constants.INDEX_END_DATE];
			}
			// 5 words - 24 Nov to 26 Nov
			if (isDateRange(word + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_5TH_WORD])) {
				return createDatesFromRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_5TH_WORD])[Constants.INDEX_END_DATE];
			}

			// more than 5 words
			if (i + Constants.INDEX_4TH_WORD < words.length) {
				String[] words4to7 = getNext4Words(words, i
						+ Constants.INDEX_4TH_WORD);
				// 6 words - 24 nov 14 to 26 nov
				if (isDateRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_5TH_WORD] + Constants.SPACE
						+ words4to7[Constants.INDEX_4TH_WORD])) {
					return createDatesFromRange(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_4TH_WORD])[Constants.INDEX_END_DATE];
				}

				// 7 words - 30 dec 2014 to 2 jan 2015
				if (isDateRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_5TH_WORD] + Constants.SPACE
						+ words4to7[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ words4to7[Constants.INDEX_5TH_WORD])) {
					return createDatesFromRange(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_5TH_WORD])[Constants.INDEX_END_DATE];
				}
			}
			// no date range starting from this word
		}
		return null;
	}

	/**
	 * Returns the userInput without the due date and keywords preceding that
	 * due date. Example: if userInput is "add task on 6 oct", returns
	 * "add task"
	 * 
	 * @return userInput without the due date and keywords preceding that due
	 *         date
	 */
	public String getUserInputWithoutDueDate() {
		if (getDueDate() == null) {
			return getUserInput();
		}
		String keyword = getDateKeyword();
		String date = Constants.EMPTY_STRING;

		if (keyword.isEmpty()) {
			String temp = getUserInput();
			String[] words = temp.split(Constants.SPACE);

			for (int i = 0; i < words.length; i++) {
				String word = words[i];

				if (isValidDay(word) && getEndDate() == null) {
					date = word.trim();
					break;
				}

				/*
				 * find next 4 words because date and time formats (excluding
				 * date range) can have at most 5 words
				 */
				String[] nextWords = getNext4Words(words, i);

				/* check for date range */
				// 1 word - 24-26/11
				if (isDateRange(word)) {
					date = word;
					break;
				}
				// 2 words - 24-26 nov
				if (isDateRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD])) {
					date = word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD];
					break;
				}
				// 3 words - sun - tue, 24/11 to 26/11
				if (isDateRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD])) {
					date = word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD];
					break;
				}
				// 4 words - 24 to 29 Nov
				if (isDateRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD])) {
					date = word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD];
					break;
				}
				// 5 words - 24 Nov to 26 Nov
				if (isDateRange(word + Constants.SPACE
						+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
						+ nextWords[Constants.INDEX_5TH_WORD])) {
					date = word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD];
					break;
				}

				// more than 5 words
				if (i + Constants.INDEX_4TH_WORD < words.length) {
					String[] words4to7 = getNext4Words(words, i
							+ Constants.INDEX_4TH_WORD);

					// 7 words - 30 dec 2014 to 2 jan 2015
					if (isDateRange(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_5TH_WORD])) {
						date = word + Constants.SPACE
								+ nextWords[Constants.INDEX_2ND_WORD]
								+ Constants.SPACE
								+ nextWords[Constants.INDEX_3RD_WORD]
								+ Constants.SPACE
								+ nextWords[Constants.INDEX_4TH_WORD]
								+ Constants.SPACE
								+ nextWords[Constants.INDEX_5TH_WORD]
								+ Constants.SPACE
								+ words4to7[Constants.INDEX_4TH_WORD]
								+ Constants.SPACE
								+ words4to7[Constants.INDEX_5TH_WORD];
						break;
					}

					// 6 words - 24 nov 14 to 26 nov
					if (isDateRange(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]
							+ Constants.SPACE
							+ words4to7[Constants.INDEX_4TH_WORD])) {
						date = word + Constants.SPACE
								+ nextWords[Constants.INDEX_2ND_WORD]
								+ Constants.SPACE
								+ nextWords[Constants.INDEX_3RD_WORD]
								+ Constants.SPACE
								+ nextWords[Constants.INDEX_4TH_WORD]
								+ Constants.SPACE
								+ nextWords[Constants.INDEX_5TH_WORD]
								+ Constants.SPACE
								+ words4to7[Constants.INDEX_4TH_WORD];
						break;
					}

				}

				if (hasDate(word, nextWords)) {
					Pattern p = Pattern.compile(Constants.REGEX_WORD_START
							+ word + Constants.REGEX_WORD_END_SPACES_WORD_START
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.REGEX_WORD_END);
					Matcher m = p.matcher(temp);

					if (m.find()) {
						date = getParameterStartingAtIndex(m.start()).trim();
					}
					break;
				}
			}
		} else {
			// there is a keyword
			Pattern p = Pattern.compile(Constants.REGEX_WORD_START + keyword
					+ Constants.REGEX_WORD_END);
			Matcher m = p.matcher(getUserInput());

			while (m.find()) {
				String parameter = getParameterStartingAtIndex(m.end());
				if (isValidDateFormat(parameter)) {
					date = parameter.trim();
				}
			}
		}

		if (getDateKeyword().isEmpty()) {
			return cleanUp(getUserInput().replaceAll(
					Constants.REGEX_WORD_START + date
							+ Constants.REGEX_WORD_END, Constants.SPACE));
		} else {
			return cleanUp(getUserInput().replaceAll(
					Constants.REGEX_WORD_START + keyword
							+ Constants.REGEX_WORD_END_1SPACE_WORD_START + date
							+ Constants.REGEX_WORD_END, Constants.SPACE));
		}
	}

	/**
	 * Checks if a string is a valid date format
	 * 
	 * @param inDate
	 *            string to be checked
	 * @return true if inDate is a valid date format, else false
	 */
	public boolean isValidDateFormat(String inDate) {
		return isValidDate(inDate) || isValidDay(inDate) || isDateRange(inDate);
	}

	/**
	 * Checks if a String represents date in any of the allowed formats
	 * 
	 * @param inDate
	 *            string to be checked
	 * @return true if it matches any of the above formats, else false
	 */
	public boolean isValidDate(String inDate) {
		inDate = inDate.trim().toLowerCase();
		List<SimpleDateFormat> dateFormats = new ArrayList<SimpleDateFormat>();

		// Allowed date formats
		dateFormats.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_NUM_YEAR_LONG)); // 14/3/2014
		dateFormats.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_NUM_YEAR_SHORT)); // 14/3/14
		dateFormats.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_LONG_YEAR_LONG)); // 14
																		// March
																		// 2014
		dateFormats.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_LONG_YEAR_SHORT)); // 14
																		// March
																		// 14
		dateFormats.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_NUM)); // 14/3

		for (SimpleDateFormat format : dateFormats) {
			format.setLenient(false);
			try {
				format.parse(inDate.trim());
				return true;
			} catch (ParseException pe) {
				// Try other formats
			}
		}

		List<SimpleDateFormat> dateFormatsAbbreviatedMonth = new ArrayList<SimpleDateFormat>();
		// 14 Mar 2014
		dateFormatsAbbreviatedMonth.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_SHORT_YEAR_LONG));

		// 14 Mar 14
		dateFormatsAbbreviatedMonth.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_SHORT_YEAR_SHORT));

		// 14 Mar
		dateFormatsAbbreviatedMonth.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_SHORT));

		// 14 March
		dateFormatsAbbreviatedMonth.add(new SimpleDateFormat(
				Constants.DATE_FORMAT_DAY_NUM_MONTH_LONG));

		for (SimpleDateFormat format : dateFormatsAbbreviatedMonth) {
			format.setLenient(false);
			try {
				format.parse(inDate.trim());
				String month = getNthWord(inDate, 2); // get the 2nd word
				for (String fullMonthName : Constants.MONTHS_LONG) {
					if (fullMonthName.contains(month)) {
						return true;
					}
				}
			} catch (ParseException pe) {
				// Try other formats
			}
		}
		return false;
	}

	/**
	 * Given a string that represents a valid date, creates a Date object
	 * 
	 * @param string
	 *            String representing date in any of the allowed formats
	 * @return Date object if string is a valid date, else null
	 */
	public Date createDate(String string) {
		if (!isValidDate(string) && !isValidDay(string)) {
			return null;
		}

		String[] dateSlash = string.split(Constants.SEPARATOR_SLASH); // separated
																		// by
																		// forward-slash
		dateSlash = cleanUp(dateSlash);
		String[] dateSpace = string.split(Constants.SPACE); // separated by
															// space
		dateSpace = cleanUp(dateSpace);

		// Date format 30/9/2014 or 30/9/14
		// if the date has 3 parts
		if (dateSlash.length == Constants.LENGTH_DAY_MONTH_YEAR) {
			if (Integer.parseInt(dateSlash[Constants.INDEX_DAY]) < Constants.LIMIT_ZERO
					|| Integer.parseInt(dateSlash[Constants.INDEX_MONTH]) < Constants.LIMIT_ZERO
					|| Integer.parseInt(dateSlash[Constants.INDEX_YEAR]) < Constants.LIMIT_ZERO) {
				return null;
			}
			return new Date(Integer.parseInt(dateSlash[Constants.INDEX_DAY]),
					Integer.parseInt(dateSlash[Constants.INDEX_MONTH]),
					Integer.parseInt(dateSlash[Constants.INDEX_YEAR]));
		}

		// Date format 30 September 2014 or 30 Sep 2014 or 30 September 14 or 30
		// Sep 14
		// if the date has 3 parts
		if (dateSpace.length == Constants.LENGTH_DAY_MONTH_YEAR) {
			// get number of month e.g 1 for jan
			int monthNum = getMonthNum(dateSpace[Constants.INDEX_MONTH]);
			if (Integer.parseInt(dateSpace[Constants.INDEX_DAY]) < Constants.LIMIT_ZERO
					|| monthNum < Constants.LIMIT_ZERO
					|| Integer.parseInt(dateSpace[Constants.INDEX_YEAR]) < Constants.LIMIT_ZERO) {
				return null;
			}
			return new Date(Integer.parseInt(dateSpace[Constants.INDEX_DAY]),
					monthNum, Integer.parseInt(dateSpace[Constants.INDEX_YEAR]));
		}

		// Date format 30/9
		// if the date has 2 parts
		if (dateSlash.length == Constants.LENGTH_DAY_MONTH) {
			if (Integer.parseInt(dateSlash[Constants.INDEX_DAY]) < Constants.LIMIT_ZERO
					|| Integer.parseInt(dateSlash[Constants.INDEX_MONTH]) < Constants.LIMIT_ZERO) {
				return null;
			}
			return new Date(Integer.parseInt(dateSlash[Constants.INDEX_DAY]),
					Integer.parseInt(dateSlash[Constants.INDEX_MONTH]));
		}

		// Date format 30 September or 30 Sep
		// if the date has 2 parts
		if (dateSpace.length == Constants.LENGTH_DAY_MONTH) {
			// get number of month e.g 1 for jan
			int monthNum = getMonthNum(dateSpace[Constants.INDEX_MONTH]);
			if (Integer.parseInt(dateSpace[Constants.INDEX_DAY]) < Constants.LIMIT_ZERO
					|| monthNum < Constants.LIMIT_ZERO) {
				return null;
			}
			return new Date(Integer.parseInt(dateSpace[Constants.INDEX_DAY]),
					monthNum);
		}

		// Day of the week - Monday, Mon
		// if string has 1 word and day of the week is valid
		if (LOLParser.countWords(string) == 1
				&& (LOLParser.hasWordInDictionary(Constants.DAYS_SHORT, string) || LOLParser
						.hasWordInDictionary(Constants.DAYS_LONG, string))) {

			// get index of today's day and due date, 0 - sun, 1 - mon and so on
			int todaysDayOfTheWeekIndex = getTodaysDayOfTheWeekIndex(); // 0-6
			int dueDatesDayOfTheWeekIndex = getDayOfTheWeekIndex(string); // 0-6

			// how many days later is the due date from today, e.g 1 if due date
			// is tomorrow
			int numDaysLater = dueDatesDayOfTheWeekIndex
					- todaysDayOfTheWeekIndex;

			// if today's index > due date's index, due date is next week
			// E.g. If today is Friday, Mon refers to next Monday
			if (numDaysLater < 1) {
				numDaysLater += Constants.NUMBER_OF_DAYS_IN_A_WEEK;
			}
			return addDaysToToday(numDaysLater);
		}

		// today, tomorrow, tmw, tmr, tmrw
		if (LOLParser.countWords(string) == 1
				&& LOLParser.hasWordInDictionary(Constants.DAYS_IMMEDIATE,
						string)) {
			if (string
					.equalsIgnoreCase(Constants.DAYS_IMMEDIATE[Constants.INDEX_TODAY])) { // today
				return getTodaysDate();
			} else { // tomorrow
				return addDaysToToday(1);
			}
		}

		return new Date(); // Date does not match any of the above formats
	}

	/**
	 * Returns index of month, starting from 1. Example: 1 for Jan, 2 for Feb
	 * ... 12 for Dec
	 * 
	 * @param month
	 *            month name in 3-letters short form (jan) or full name of the
	 *            month (january) - not case-sensitive
	 * @return index of month if month is valid, else -1
	 */
	public int getMonthNum(String month) {
		for (int i = 0; i < Constants.MONTHS_SHORT.length; i++) {
			if (month.equalsIgnoreCase(Constants.MONTHS_SHORT[i])
					|| month.equalsIgnoreCase(Constants.MONTHS_LONG[i])) {
				return i + 1;
			}
		}
		return Constants.NOT_FOUND;
	}

	/**
	 * Returns index of day of the week, starting from 0 for Sunday. Example: 0
	 * for Sun, 1 for Mon, 2 for Tue ... 6 for Sat
	 * 
	 * @param string
	 *            day name in 3-letters short form (mon) or full name of the day
	 *            (monday) - not case-sensitive
	 * @return index of day of the week if valid, else -1
	 */
	public int getDayOfTheWeekIndex(String string) {
		for (int i = 0; i < Constants.DAYS_SHORT.length; i++) {
			if (string.equalsIgnoreCase(Constants.DAYS_SHORT[i])
					|| string.equalsIgnoreCase(Constants.DAYS_LONG[i])) {
				return i;
			}
		}
		return Constants.NOT_FOUND;
	}

	/**
	 * Checks if a string represents a day in any of the following formats: Day
	 * of the week - Monday, Mon, Sunday, Sun, etc. (or) today (or) tomorrow
	 * (or) tmw, not case-sensitive
	 * 
	 * @param string
	 *            string to be checked
	 * @return true if it matches any of the above formats, else false
	 */
	public boolean isValidDay(String string) {
		string = string.trim();

		// Day of the week - Monday, Mon
		if (LOLParser.countWords(string) == 1
				&& (LOLParser.hasWordInDictionary(Constants.DAYS_SHORT, string) || LOLParser
						.hasWordInDictionary(Constants.DAYS_LONG, string))) {
			return true;
		}

		// today, tomorrow, tmw
		if (LOLParser.countWords(string) == 1
				&& LOLParser.hasWordInDictionary(Constants.DAYS_IMMEDIATE,
						string)) {
			return true;
		}
		return false;
	}

	/**
	 * Returns today's date
	 * 
	 * @return Date object containing today's date
	 */
	public Date getTodaysDate() {
		Calendar rightNow = Calendar.getInstance(); // Get the current date
		return new Date(rightNow.get(Calendar.DATE),
				rightNow.get(Calendar.MONTH) + 1, rightNow.get(Calendar.YEAR));
	}

	/**
	 * Returns a date which is a specified number of days after today
	 * 
	 * @param amount
	 *            number of days after today, if negative then decrement
	 * @return advanced date if amount is positive, earlier date if amount is
	 *         negative
	 */
	public Date addDaysToToday(int amount) {
		Calendar rightNow = Calendar.getInstance(); // Get the current date
		rightNow.setTime(new java.util.Date());
		rightNow.add(Calendar.DATE, amount);
		return new Date(rightNow.get(Calendar.DATE),
				rightNow.get(Calendar.MONTH) + 1, rightNow.get(Calendar.YEAR));
	}

	/**
	 * @return which day of the week (sunday, monday ... saturday) it is today
	 */
	public String getTodaysDayOfTheWeek() {
		Calendar rightNow = Calendar.getInstance(); // Get the current date
		// sun = 0, mon = 1 ... sat = 6
		return Constants.DAYS_LONG[rightNow.get(Calendar.DAY_OF_WEEK) - 1];
	}

	/**
	 * @return the index of which day of the week (0-sun, 1-mon ... 6-sat) it is
	 *         today
	 */
	public int getTodaysDayOfTheWeekIndex() {
		Calendar rightNow = Calendar.getInstance(); // Get the current date
		// sun = 0, mon = 1 ... sat = 6
		return rightNow.get(Calendar.DAY_OF_WEEK) - 1;
	}

	/**
	 * Returns the first 3 letters of the day of the week for a given date
	 * 
	 * @param date
	 *            date whose day of the week is to be found
	 * @return first 3 letters of the day of the week, 1st letter uppercase
	 */
	public String getDayOfTheWeek(Date date) {
		Calendar cal = Calendar.getInstance();
		cal.set(date.getYear4Digit(), date.getMonth() - 1, date.getDay());
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK); // 1-sun to 7-sat
		String day = Constants.DAYS_SHORT[dayOfWeek - 1];
		return Character.toUpperCase(day.charAt(Constants.INDEX_1ST_LETTER))
				+ day.substring(Constants.INDEX_2ND_LETTER);
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces
	 * 
	 * @param input
	 *            string to be cleaned up
	 * @return string without extra spaces
	 */
	public String cleanUp(String input) {
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		return input;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces for
	 * all strings in an array
	 * 
	 * @param input
	 *            array containing strings to be formatted
	 * @return array with formatted strings
	 */
	public String[] cleanUp(String[] input) {
		for (int i = 0; i < input.length; i++) {
			String temp = input[i];
			temp = temp.trim();
			temp = cleanUp(temp);
			input[i] = temp;
		}
		return input;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces in the
	 * userInput
	 * 
	 * @return string without extra spaces
	 */
	public String cleanUp() {
		String input = getUserInput();
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		setUserInput(input);
		return input;
	}

	/**
	 * Returns the Nth word of an input, where n starts from 1, e.g. 1 for 1st
	 * word
	 * 
	 * @param input
	 *            input string
	 * @param n
	 *            the index of word to return, starting from 1
	 * @return Nth word of input
	 */
	public String getNthWord(String input, int n) {
		input = cleanUp(input);
		String[] words = input.split(Constants.SPACE);
		if (words.length < n) {
			return Constants.EMPTY_STRING;
		} else {
			return words[n - 1];
		}
	}

	/**
	 * Returns a due date starting from 'index' till the occurrence of another
	 * reserved word or the end of the string or another parameter, whichever is
	 * earlier
	 * 
	 * @param index
	 *            index of userInput at which the paramter to be returned starts
	 * @return parameter starting from index
	 */
	public String getParameterStartingAtIndex(int index) {
		if (isIndexOutOfBounds(index)) {
			return null;
		}
		String parameter;
		int nextKeywordIndex = getIndexOfNextReservedWord(index + 1);

		if (nextKeywordIndex == Constants.NOT_FOUND) {
			parameter = getUserInput().substring(index).trim();
		} else {
			assert nextKeywordIndex > Constants.LIMIT_ZERO;
			parameter = getUserInput().substring(index, nextKeywordIndex)
					.trim();
		}

		// Check if the due date is followed by a description
		if (isDateRange(parameter)) {
			return removeDescriptionFromDateRangeIfAny(parameter);
		} else {
			return removeDescriptionFromDueDateIfAny(parameter);
		}
	}

	/**
	 * Checks if a string represents a 2 digit year from 10 to 99 or 4 digit
	 * year from 2010 to 2099
	 * 
	 * @param year
	 *            string to be checked
	 * @return true if the string is a year, else false
	 */
	public boolean isYear(String year) {
		try {
			int yr = Integer.parseInt(year);
			return (yr >= Constants.LIMIT_MIN_2DIGIT_YEAR && yr <= Constants.LIMIT_MAX_2DIGIT_YEAR)
					|| (yr >= Constants.LIMIT_MIN_4DIGIT_YEAR && yr <= Constants.LIMIT_MAX_4DIGIT_YEAR);
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Removes task description after a due date, if any
	 * 
	 * @param date
	 *            String containing a due date which may or may not be followed
	 *            by a task description
	 * @return due date as a String
	 */
	public String removeDescriptionFromDueDateIfAny(String date) {
		String[] words = date.split(Constants.SPACE);
		String firstWord = words[Constants.INDEX_1ST_WORD];
		String[] nextWords = getNext4Words(words, Constants.INDEX_1ST_WORD);

		if (isValidDateFormat(firstWord)) {
			return firstWord.trim();
		} else if (isValidDateFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD])
				&& !(isYear(nextWords[Constants.INDEX_3RD_WORD]))) {
			return (firstWord + Constants.SPACE + nextWords[Constants.INDEX_2ND_WORD])
					.trim();
		} else if (isValidDateFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_3RD_WORD])
				&& !(isYear(nextWords[Constants.INDEX_4TH_WORD]))) {
			return (firstWord + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE + nextWords[Constants.INDEX_3RD_WORD])
					.trim();
		} else if (isValidDateFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_4TH_WORD])
				&& !(isYear(nextWords[Constants.INDEX_5TH_WORD]))) {
			return (firstWord + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE + nextWords[Constants.INDEX_4TH_WORD])
					.trim();
		} else {
			return date;
		}
	}

	/**
	 * Removes task description after a date range, if any
	 * 
	 * @param dateRange
	 *            String containing a date range which may or may not be
	 *            followed by a task description
	 * @return date range as a String
	 */
	public String removeDescriptionFromDateRangeIfAny(String dateRange) {
		while (!dateRange.isEmpty() && !isDateRange(dateRange)) {
			dateRange = removeLastWord(dateRange);
		}
		return dateRange;
	}

	/**
	 * Removes the last word from a String
	 * 
	 * @param string
	 *            string from which last word is to be removed
	 * @return String without the last word. If there is only one word or less,
	 *         an empty string is returned.
	 */
	public String removeLastWord(String string) {
		string = cleanUp(string);
		int index = string.lastIndexOf(Constants.SPACE_CHAR);
		if (index == Constants.NOT_FOUND) {
			return "";
		} else {
			return string.substring(Constants.INDEX_BEGIN, index);
		}
	}

	/**
	 * Returns the starting index of the next keyword
	 * 
	 * @param beginIndex
	 *            index of userInput to start searching from
	 * @return starting index of next keyword, -1 if not found
	 */
	public int getIndexOfNextReservedWord(int beginIndex) {
		String temp = getUserInput().substring(beginIndex);
		String[] words = temp.split(Constants.SPACE);
		int minIndex = Constants.NOT_FOUND;

		for (int i = 0; i < words.length; i++) {
			String word = words[i];
			String[] nextWords = getNext4Words(words, i);

			if (isKeyword(word)
					|| (hasTime(word, nextWords)
							&& !(word.startsWith(Constants.STRING_ZERO) && word
									.endsWith(Constants.STRING_M_LOWERCASE)) && !isBoth24hrTimeAndYear(word))) {
				Pattern p = Pattern.compile(Constants.REGEX_WORD_START + word
						+ Constants.REGEX_WORD_END_SPACES_WORD_START
						+ nextWords[Constants.INDEX_2ND_WORD]
						+ Constants.REGEX_WORD_END);
				Matcher m = p.matcher(temp);

				if (m.find()) {
					int keywordIndex = m.start() + beginIndex;
					if (minIndex == Constants.NOT_FOUND
							|| keywordIndex < minIndex) {
						minIndex = keywordIndex;
					}
				}
			}
		}
		return minIndex;
	}

	/**
	 * Checks if a string is both a year and a 24hr time format
	 * 
	 * @param string
	 *            string to be checked
	 * @return true if string is both a year and a 24hr time format, else false
	 */
	public boolean isBoth24hrTimeAndYear(String string) {
		TimeParser tp = new TimeParser();
		return isYear(string) && tp.is24hrTime(string);
	}

	/**
	 * Checks whether the word and the next 4 words form a valid date
	 * 
	 * @param word
	 *            first word
	 * @param nextWords
	 *            second to fifth words, if there are less than 4 elements,
	 *            empty strings are entered for the array element
	 * @return true if word and nextWords contain a valid date, else false
	 */
	public boolean hasDate(String word, String[] nextWords) {
		try {
			return isValidDateFormat(word)
					|| isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD])
					|| isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD])
					|| isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD])
					|| isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]);
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks whether the word and the next 4 words form a valid time or time
	 * range
	 * 
	 * @param word
	 *            first word
	 * @param nextWords
	 *            second to fifth words, if there are less than 4 elements,
	 *            empty strings are entered for the array element
	 * @return true if word and nextWords contain a valid time format, else
	 *         false
	 */
	public boolean hasTime(String word, String[] nextWords) {
		TimeParser tp = new TimeParser();
		try {
			return tp.isValidTimeFormat(word)
					|| tp.isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD])
					|| tp.isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD])
					|| tp.isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD])
					|| tp.isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]);
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks is a word is a keyword (at, by etc.) but not a reserved word (days
	 * of the week, today, tomorrow, tmw)
	 * 
	 * @param word
	 *            word to be checked
	 * @return true if a word is a keyword but not reserved word, else false
	 */
	public boolean isKeyword(String word) {
		return hasWordInDictionary(Constants.KEYWORDS, word);
	}

	/**
	 * Checks whether index is out of bounds for userInput
	 * 
	 * @param index
	 *            index to be checked
	 * @return true if index out of bounds, else false
	 */
	public boolean isIndexOutOfBounds(int index) {
		return index < Constants.LIMIT_ZERO || index >= getUserInput().length();
	}

	/**
	 * Check whether a word appears in a dictionary
	 * 
	 * @param dictionary
	 *            Dictionary to be searched
	 * @param word
	 *            Word to search for
	 * @return true if word appears in dictionary, false otherwise
	 */
	public boolean hasWordInDictionary(String[] dictionary, String word) {
		word = word.trim();
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(word)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Returns the next 4 words of userInput, starting from the index i + 1
	 * 
	 * @param words
	 *            Array of words in userInput
	 * @param i
	 *            The index of the first word
	 * @return The next 4 words after index i. If there are less than 4 words,
	 *         the empty words are represented by empty strings
	 */
	public String[] getNext4Words(String[] words, int i) {
		String[] nextWords = { Constants.EMPTY_STRING, Constants.EMPTY_STRING,
				Constants.EMPTY_STRING, Constants.EMPTY_STRING };

		if (i < words.length - 4) {
			int index = 0;
			while (index < 4) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 3) {
			int index = 0;
			while (index < 3) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 2) {
			int index = 0;
			while (index < 2) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 1) {
			int index = 0;
			while (index < 1) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else {
			assert i == words.length - 1;
		}
		return nextWords;
	}

	/**
	 * Checks whether a string is a date range in the following formats: (Space
	 * before and after 'to') <date1> to <date2> e.g. 24 Nov to 26 Nov, 24 to 26
	 * Nov 14 <date1>-<date2> e.g. 24/11-26/11, 24-26 Nov, 24-26 Nov 2014
	 * 
	 * @param string
	 *            string to be checked
	 * @return true if the string is a date range in any of the above formats,
	 *         else false
	 */
	public boolean isDateRange(String string) {
		boolean containsSeparator = false;
		String[] dates = {};

		try {
			if (string.contains(Constants.SEPARATOR_TO)) {
				dates = string.split(Constants.SEPARATOR_TO);
				dates = cleanUp(dates);
				containsSeparator = true;
			} else if (string.contains(Constants.SEPARATOR_DASH)) {
				dates = string.split(Constants.SEPARATOR_DASH);
				dates = cleanUp(dates);
				containsSeparator = true;
			}

			if (containsSeparator) {
				// start and end date are both valid dates, e.g. 24 Nov to 26
				// Nov, 24/11-26/11, sun-tue
				if ((isValidDate(dates[Constants.INDEX_START_DATE]) || isValidDay(dates[Constants.INDEX_START_DATE]))
						&& (isValidDate(dates[Constants.INDEX_END_DATE]) || isValidDay(dates[Constants.INDEX_END_DATE]))) {
					// if both are days of the week e.g sun-tue
					if (isDayOfTheWeek(dates[Constants.INDEX_START_DATE])
							&& isDayOfTheWeek(dates[Constants.INDEX_END_DATE])) {
						return true;
					}
					Date start = createDate(dates[Constants.INDEX_START_DATE]);
					Date end = createDate(dates[Constants.INDEX_END_DATE]);
					return start.isBefore(end);
				}
				// start date is the day only, end date is a valid date, e.g.
				// 24-26 Nov, 24 to 26 nov
				if (isValidDate(dates[Constants.INDEX_END_DATE])) {
					Date end = createDate(dates[Constants.INDEX_END_DATE]);
					return Integer.parseInt(dates[Constants.INDEX_START_DATE]) < end
							.getDay();
				}
			}
			return false;
		} catch (Exception e) {
			return false;
		}
	}

	public boolean isDayOfTheWeek(String string) {
		return hasWordInDictionary(Constants.DAYS_LONG, string)
				|| hasWordInDictionary(Constants.DAYS_SHORT, string);
	}

	public boolean isEitherTodayOrTmr(String string) {
		return hasWordInDictionary(Constants.DAYS_IMMEDIATE, string);
	}

	/**
	 * Given a string that represents a date range, creates an array of Date
	 * objects of start date and end date
	 * 
	 * @param string
	 *            date range
	 * @return array with start date and end date, null if invalid format
	 */
	public Date[] createDatesFromRange(String string) {
		string = string.trim().toLowerCase();
		String[] dates = {};

		try {
			if (!isDateRange(string)) {
				return null;
			}
			if (string.contains(Constants.SEPARATOR_TO)) {
				dates = cleanUp(string.split(Constants.SEPARATOR_TO));
			} else if (string.contains(Constants.SEPARATOR_DASH)) {
				dates = cleanUp(string.split(Constants.SEPARATOR_DASH));
			} else {
				return null;
			}

			// start and end date are both valid dates, e.g. 24 Nov to 26 Nov,
			// 24/11-26/11, sun-tue
			if ((isValidDate(dates[Constants.INDEX_START_DATE]) || isValidDay(dates[Constants.INDEX_START_DATE]))
					&& (isValidDate(dates[Constants.INDEX_END_DATE]) || isValidDay(dates[Constants.INDEX_END_DATE]))) {

				// if both are days of the week
				if (isDayOfTheWeek(dates[Constants.INDEX_START_DATE])
						&& isDayOfTheWeek(dates[Constants.INDEX_END_DATE])) {
					Date start = createDate(dates[Constants.INDEX_START_DATE]);

					int startDayIndex = getDayOfTheWeekIndex(dates[Constants.INDEX_START_DATE]);
					int endDayIndex = getDayOfTheWeekIndex(dates[Constants.INDEX_END_DATE]);
					int duration = endDayIndex - startDayIndex;

					if (duration <= Constants.LIMIT_ZERO) {
						duration += Constants.NUMBER_OF_DAYS_IN_A_WEEK;
					}
					Date end = addDaysToDate(start, duration);

					Date[] dateArr = { start, end };
					return dateArr;
				} else {
					Date start = createDate(dates[Constants.INDEX_START_DATE]);
					Date end = createDate(dates[Constants.INDEX_END_DATE]);
					Date[] dateArr = { start, end };
					return dateArr;
				}
			} else if (isValidDate(dates[Constants.INDEX_END_DATE])) {
				// start date is the day only, end date is a valid date, e.g.
				// 24-26 Nov, 24 to 26 nov
				Date end = createDate(dates[Constants.INDEX_END_DATE]);
				Date start = new Date(
						Integer.parseInt(dates[Constants.INDEX_START_DATE]),
						end.getMonth(), end.getYear4Digit());
				Date[] dateArr = { start, end };
				return dateArr;
			}
			return null;
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Adds a specific number of days to a given date
	 * 
	 * @param date
	 *            date to which days are to be added
	 * @param amount
	 *            number of days to be added
	 * @return advanced date
	 */
	public Date addDaysToDate(Date date, int amount) {
		Calendar cal = Calendar.getInstance();
		cal.set(date.getYear4Digit(), date.getMonth() - 1, date.getDay());
		cal.add(Calendar.DATE, amount);
		return new Date(cal.get(Calendar.DATE), cal.get(Calendar.MONTH) + 1,
				cal.get(Calendar.YEAR));
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\DateParser.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\DateParserTest.java
	 */


package parser;

import static org.junit.Assert.*;
import lol.Date;

import org.junit.Test;

public class DateParserTest {
	@Test
	public void testGetDueDate() {
		DateParser dp1 = new DateParser(
				"  add   buy   pizza  at clementi  on  29 oct at   10am ");
		assertEquals(new Date(29, 10), dp1.getDueDate());
		assertEquals("on", dp1.getDateKeyword());
		DateParser dp = new DateParser(
				"  add  do something by  31/12 at home  at   10am ");
		assertEquals(new Date(31, 12), dp.getDueDate());
		assertEquals("by", dp.getDateKeyword());
		DateParser dp2 = new DateParser(
				"  add by  31/12 do something  at home  at   10am ");
		assertEquals(new Date(31, 12), dp2.getDueDate());
		DateParser dp3 = new DateParser("  add do something 12/11");
		assertEquals(new Date(12, 11), dp3.getDueDate());
		DateParser dp4 = new DateParser("add eat at 10 food place 10 oct ");
		assertEquals(new Date(10, 10), dp4.getDueDate());
		DateParser dp5 = new DateParser("add eat 3 pizzas on 3 nov at 3 pm");
		assertEquals(new Date(3, 11), dp5.getDueDate());
		DateParser dp6 = new DateParser("add eat 3 octo");
		assertEquals(null, dp6.getDueDate());

		/* This is an equivalence partition for date range */
		DateParser dp7 = new DateParser("add camp at island from 12-15 Dec");
		assertEquals(new Date(12, 12, 14), dp7.getDueDate());
		DateParser dp8 = new DateParser(
				"add camp at island from 24/11 to 2 dec");
		assertEquals(new Date(24, 11, 14), dp8.getDueDate());
		DateParser dp9 = new DateParser(
				"add camp at island from 24 Dec 2014 to 2 Jan 2015");
		assertEquals(new Date(24, 12, 14), dp9.getDueDate());

		DateParser dp10 = new DateParser("add camp at island 12-15 Dec");
		assertEquals(new Date(12, 12, 14), dp10.getDueDate());
		DateParser dp11 = new DateParser("add camp at island 24/11 to 2 dec");
		assertEquals(new Date(24, 11, 14), dp11.getDueDate());
		DateParser dp12 = new DateParser(
				"add camp at island 24 Dec 2014 to 2 Jan 2015");
		assertEquals(new Date(24, 12, 14), dp12.getDueDate());
	}

	@Test
	public void testGetEndDate() {
		DateParser dp6 = new DateParser("add eat 3 octo");
		assertEquals(null, dp6.getEndDate());
		DateParser dp7 = new DateParser("add camp at island from 12-15 Dec");
		assertEquals(new Date(15, 12, 14), dp7.getEndDate());
		DateParser dp8 = new DateParser(
				"add camp at island from 24/11 to 2 dec");
		assertEquals(new Date(2, 12, 14), dp8.getEndDate());
		DateParser dp9 = new DateParser(
				"add camp at island from 24 Dec 2014 to 2 Jan 2015");
		assertEquals(new Date(2, 1, 2015), dp9.getEndDate());
	}

	@Test
	public void testGetDayOfTheWeek() {
		DateParser dp = new DateParser();
		assertEquals("Wed", dp.getDayOfTheWeek(new Date(22, 10, 2014)));
		assertEquals("Thu", dp.getDayOfTheWeek(new Date(23, 10, 2014)));
		assertEquals("Fri", dp.getDayOfTheWeek(new Date(24, 10, 2014)));
		assertEquals("Sat", dp.getDayOfTheWeek(new Date(25, 10, 2014)));
		assertEquals("Sun", dp.getDayOfTheWeek(new Date(26, 10, 2014)));
	}

	@Test
	public void testGetUserInputWithoutDueDate() {
		DateParser dp1 = new DateParser(
				"  add   buy   pizza  at clementi  on  29 oct at   10am ");
		assertEquals("add buy pizza at clementi at 10am",
				dp1.getUserInputWithoutDueDate());
		DateParser dp2 = new DateParser(
				"  add   buy   pizza at   10am  at clementi  by  29 oct ");
		assertEquals("add buy pizza at 10am at clementi",
				dp2.getUserInputWithoutDueDate());
		DateParser dp3 = new DateParser(
				"  add   buy   pizza  at clementi at   10am ");
		assertEquals("add buy pizza at clementi at 10am",
				dp3.getUserInputWithoutDueDate());
		DateParser dp4 = new DateParser(
				"  add 30/10  buy   pizza  at clementi at   10am ");
		assertEquals("add buy pizza at clementi at 10am",
				dp4.getUserInputWithoutDueDate());
		DateParser dp5 = new DateParser("  add eat at 10 food place 10 oct");
		assertEquals("add eat at 10 food place",
				dp5.getUserInputWithoutDueDate());
		DateParser dp6 = new DateParser("add on mon do something 8-10pm");
		assertEquals("add do something 8-10pm",
				dp6.getUserInputWithoutDueDate());
		DateParser dp7 = new DateParser("add eat 3 pizzas on 3 nov at 3 pm");
		assertEquals("add eat 3 pizzas at 3 pm",
				dp7.getUserInputWithoutDueDate());
		DateParser dp8 = new DateParser("add mon do this");
		assertEquals("add do this", dp8.getUserInputWithoutDueDate());

		/* This is an equivalence partition for date range */
		DateParser dp10 = new DateParser(
				"add camp at island from 12-15 Dec at 8am");
		assertEquals("add camp at island at 8am",
				dp10.getUserInputWithoutDueDate());
		DateParser dp20 = new DateParser(
				"add at island  from 24/11 to 2/12 9am camp");
		assertEquals("add at island 9am camp",
				dp20.getUserInputWithoutDueDate());
		DateParser dp9 = new DateParser(
				"add camp at island from 24 Dec 2014 to 2 Jan 2015");
		assertEquals("add camp at island", dp9.getUserInputWithoutDueDate());

		DateParser dp11 = new DateParser("add camp at island on 12-15 Dec");
		assertEquals("add camp at island", dp11.getUserInputWithoutDueDate());
		DateParser dp12 = new DateParser("add camp at island on 24/11 to 2/12");
		assertEquals("add camp at island", dp12.getUserInputWithoutDueDate());
		DateParser dp13 = new DateParser(
				"add camp at island on 24 Dec 2014 to 2 Jan 2015");
		assertEquals("add camp at island", dp13.getUserInputWithoutDueDate());

		DateParser dp14 = new DateParser("add at island 9am 12-15 Dec camp");
		assertEquals("add at island 9am camp",
				dp14.getUserInputWithoutDueDate());
		DateParser dp15 = new DateParser("add at island 24/11 to 2/12 camp");
		assertEquals("add at island camp", dp15.getUserInputWithoutDueDate());
		DateParser dp16 = new DateParser(
				"add camp at island 24 Dec 2014 to 2 Jan 2015 8.30-10am");
		assertEquals("add camp at island 8.30-10am",
				dp16.getUserInputWithoutDueDate());
	}

	@Test
	public void testIsValidDate() {
		DateParser dp = new DateParser();
		assertTrue(dp.isValidDate("31 oct"));
		assertTrue(dp.isValidDate("31 october"));
		assertTrue(dp.isValidDate("31 oct 2014"));
		assertTrue(dp.isValidDate("31 october 2014"));
		assertTrue(dp.isValidDate("31 oct 14"));
		assertTrue(dp.isValidDate("31 october 14"));
		assertTrue(dp.isValidDate("31/10"));
		assertTrue(dp.isValidDate("31/10/14"));
		assertTrue(dp.isValidDate("31/10/2014"));
		assertFalse(dp.isValidDate("31/13/14"));
		assertFalse(dp.isValidDate("abcde"));
		assertFalse(dp.isValidDate("5 novel"));
		assertTrue(dp.isValidDate("16 octo 15"));
		assertFalse(dp.isValidDate("16"));
	}

	@Test
	public void testCreateDate() {
		DateParser dp = new DateParser();
		assertEquals(new Date(31, 10, 15), dp.createDate("31 oct"));
		assertEquals(new Date(31, 10, 15), dp.createDate("31/10"));
		assertEquals(null, dp.createDate("abcde"));
	}

	@Test
	public void testGetMonthNum() {
		DateParser dp = new DateParser();
		assertEquals(1, dp.getMonthNum("jan"));
		assertEquals(2, dp.getMonthNum("february"));
		assertEquals(12, dp.getMonthNum("dec"));
		assertEquals(-1, dp.getMonthNum("abcde"));
	}

	@Test
	public void testGetDayOfTheWeekIndex() {
		DateParser dp = new DateParser();
		assertEquals(0, dp.getDayOfTheWeekIndex("sun"));
		assertEquals(2, dp.getDayOfTheWeekIndex("tuesday"));
		assertEquals(6, dp.getDayOfTheWeekIndex("sat"));
		assertEquals(-1, dp.getDayOfTheWeekIndex("abcde"));
	}

	@Test
	public void testIsValidDay() {
		DateParser dp = new DateParser();
		assertTrue(dp.isValidDay("mon"));
		assertTrue(dp.isValidDay("thursday"));
		assertTrue(dp.isValidDay("today"));
		assertTrue(dp.isValidDay("tomorrow"));
		assertTrue(dp.isValidDay("tmw"));
		assertFalse(dp.isValidDay("abcde"));
	}

	@Test
	public void testRemoveDescriptionFromDueDateIfAny() {
		DateParser dp = new DateParser();
		assertEquals("31/12",
				dp.removeDescriptionFromDueDateIfAny("31/12 do something"));
		assertEquals("mon",
				dp.removeDescriptionFromDueDateIfAny("mon do something"));
		assertEquals("31/12/15",
				dp.removeDescriptionFromDueDateIfAny("31/12/15"));
		assertEquals("31 oct 2015",
				dp.removeDescriptionFromDueDateIfAny("31 oct 2015 do that"));
	}

	@Test
	public void testIsBoth24hrTimeAndYear() {
		DateParser dp = new DateParser();
		assertTrue(dp.isBoth24hrTimeAndYear("2016"));
		assertFalse(dp.isBoth24hrTimeAndYear("1300"));
	}

	@Test
	public void testIsDateRange() {
		DateParser dp = new DateParser();
		assertTrue(dp.isDateRange("24-26 Nov"));
		assertTrue(dp.isDateRange("24 Nov - 26 Nov"));
		assertTrue(dp.isDateRange("Sun to Tue"));
		assertTrue(dp.isDateRange("24/11/14-2/12/14"));

	}

	@Test
	public void testAddDaysToDate() {
		DateParser dp = new DateParser();
		assertEquals(new Date(4, 12, 2014),
				dp.addDaysToDate(new Date(1, 12, 2014), 3));
		assertEquals(new Date(4, 11, 2014),
				dp.addDaysToDate(new Date(31, 10, 2014), 4));
	}

	@Test
	public void testCreateDatesFromRange() {
		DateParser dp = new DateParser();
		Date[] arr1 = { new Date(2, 12, 2014), new Date(5, 12, 2014) };
		assertArrayEquals(arr1, dp.createDatesFromRange("2-5 Dec"));
		Date[] arr2 = { new Date(29, 11, 2014), new Date(15, 12, 2014) };
		assertArrayEquals(arr2, dp.createDatesFromRange("29/11 to 15/12"));
	}

	// The following methods depend on the current date.

	/*
	 * @Test public void testGetTodaysDate() { DateParser dp = new DateParser();
	 * assertEquals(new Date(6,10), dp.getTodaysDate()); }
	 * 
	 * @Test public void testAddDaysToToday() { DateParser dp = new
	 * DateParser(); assertEquals(new Date(7,10), dp.addDaysToToday(1));
	 * assertEquals(new Date(5,10), dp.addDaysToToday(-1)); }
	 * 
	 * @Test public void testGetTodaysDayOfTheWeek() { DateParser dp = new
	 * DateParser(); assertEquals("monday", dp.getTodaysDayOfTheWeek()); }
	 * 
	 * @Test public void testGetTodaysDayOfTheWeekIndex() { DateParser dp = new
	 * DateParser(); assertEquals(1, dp.getTodaysDayOfTheWeekIndex()); }
	 */

}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\DateParserTest.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\DescriptionParser.java
	 */


/**
 * This class parses the description of a task.
 * 
 */

package parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lol.Constants;

public class DescriptionParser {
	/************* Attribute ***************/
	private String userInput;

	/************* Constructor ***************/
	public DescriptionParser(String userInput) {
		this.userInput = userInput;
	}

	/************* Accessor ***************/
	public String getUserInput() {
		return userInput;
	}

	/************* Mutator ***************/
	public void setUserInput(String userInput) {
		this.userInput = userInput;
	}

	/************* Other methods ***************/
	/**
	 * Returns the description of a task
	 * 
	 * @return description of a task
	 * @throws Exception
	 */
	public String getDescription() throws Exception {
		try {
			cleanUp();
			String input = getUserInput();

			// check for double quotes
			Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
			Matcher m = p.matcher(input);

			int countDoubleQuotes = countNumberOfDoubleQuotes();

			// only location and description can be enclosed in double quotes
			// more than 4 quotes and odd number of quotes are invalid
			if (countDoubleQuotes % 2 == 1 || countDoubleQuotes > 4) {
				throw new Exception(Constants.FEEDBACK_INVALID_NUMBER_OF_QUOTES);
			}

			if (countDoubleQuotes == 2) { // one parameter within quotes
				int startQuoteIndex = 0, endQuoteIndex = 0, count = 0;
				while (m.find()) {
					count++;
					if (count == 1) {
						startQuoteIndex = m.start();
					} else {
						assert count == 2;
						endQuoteIndex = m.start();
					}
				}

				// if word preceding the quote is not "at", the quote encloses a
				// description, else it contains a location
				if (!getWordBeforeQuote(startQuoteIndex).equalsIgnoreCase(
						Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
					return cleanUp(input.substring(startQuoteIndex + 1,
							endQuoteIndex));
				}

			} else if (countDoubleQuotes == 4) { // two parameters within quotes

				int firstQuoteStart = 0, firstQuoteEnd = 0, secondQuoteStart = 0, secondQuoteEnd = 0, count = 0;
				while (m.find()) {
					count++;
					if (count == 1) {
						firstQuoteStart = m.start();
					} else if (count == 2) {
						firstQuoteEnd = m.start();
					} else if (count == 3) {
						secondQuoteStart = m.start();
					} else {
						assert count == 4;
						secondQuoteEnd = m.start();
					}
				}

				// if word preceding the quote is not "at", the quote encloses a
				// description, else it contains a location
				if (!getWordBeforeQuote(firstQuoteStart).equalsIgnoreCase(
						Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
					return cleanUp(input.substring(firstQuoteStart + 1,
							firstQuoteEnd));
				}

				if (!getWordBeforeQuote(secondQuoteStart).equalsIgnoreCase(
						Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
					return cleanUp(input.substring(secondQuoteStart + 1,
							secondQuoteEnd));
				}
			}

			// either no double quotes in input or no description found within
			// double quotes
			input = removeWordsWithinQuotes(input);

			LocationParser lp = new LocationParser(input);
			String inputWithoutLocation = lp.getUserInputWithoutLocation();

			DateParser datep = new DateParser(inputWithoutLocation);
			String inputWithoutLocationAndDate = datep
					.getUserInputWithoutDueDate();

			TimeParser tp = new TimeParser(inputWithoutLocationAndDate);
			String inputWithoutLocationDateAndTime = tp
					.getUserInputWithoutTime();

			return removeFirstWord(inputWithoutLocationDateAndTime).trim();

		} catch (Exception e) {
			throw new Exception(Constants.FEEDBACK_INVALID_NUMBER_OF_QUOTES);
		}

	}

	/**
	 * Returns the number of double quotes(") in the userInput
	 * 
	 * @return number of double quotes(") in the userInput
	 */
	public int countNumberOfDoubleQuotes() {
		Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
		Matcher m = p.matcher(getUserInput());

		int count = 0;
		while (m.find()) {
			count++;
		}
		return count;
	}

	/**
	 * This method is called with user input without the command name and index.
	 * 
	 * @return description for edit command
	 */
	public String getDescriptionForEdit() throws Exception {
		cleanUp();
		String input = getUserInput();

		// check for double quotes
		Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
		Matcher m = p.matcher(input);

		int countDoubleQuotes = countNumberOfDoubleQuotes();

		// only location and description can be enclosed in double quotes
		// more than 4 quotes and odd number of quotes are invalid
		if (countDoubleQuotes % 2 == 1 || countDoubleQuotes > 4) {
			throw new Exception(Constants.FEEDBACK_INVALID_NUMBER_OF_QUOTES);
		}

		if (countDoubleQuotes == 2) { // one parameter within quotes
			int startQuoteIndex = 0, endQuoteIndex = 0, count = 0;
			while (m.find()) {
				count++;
				if (count == 1) {
					startQuoteIndex = m.start();
				} else {
					assert count == 2;
					endQuoteIndex = m.start();
				}
			}

			// if word preceding the quote is not "at", the quote encloses a
			// description, else it contains a location
			if (!getWordBeforeQuote(startQuoteIndex).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				return cleanUp(input.substring(startQuoteIndex + 1,
						endQuoteIndex));
			}

		} else if (countDoubleQuotes == 4) { // two parameters within quotes

			int firstQuoteStart = 0, firstQuoteEnd = 0, secondQuoteStart = 0, secondQuoteEnd = 0, count = 0;
			while (m.find()) {
				count++;
				if (count == 1) {
					firstQuoteStart = m.start();
				} else if (count == 2) {
					firstQuoteEnd = m.start();
				} else if (count == 3) {
					secondQuoteStart = m.start();
				} else {
					assert count == 4;
					secondQuoteEnd = m.start();
				}
			}

			// if word preceding the quote is not "at", the quote encloses a
			// description, else it contains a location
			if (!getWordBeforeQuote(firstQuoteStart).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				return cleanUp(input.substring(firstQuoteStart + 1,
						firstQuoteEnd));
			}

			if (!getWordBeforeQuote(secondQuoteStart).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				return cleanUp(input.substring(secondQuoteStart + 1,
						secondQuoteEnd));
			}
		}

		// either no double quotes in input or no description found within
		// double quotes

		// user input without command name and index
		String inputWithoutCommandAndIndex = removeWordsWithinQuotes(input);

		LocationParser lp = new LocationParser(inputWithoutCommandAndIndex);
		String inputWithoutLocation = lp.getUserInputWithoutLocation();

		DateParser datep = new DateParser(inputWithoutLocation);
		String inputWithoutLocationAndDate = datep.getUserInputWithoutDueDate();

		TimeParser tp = new TimeParser(inputWithoutLocationAndDate);
		String inputWithoutLocationDateAndTime = tp.getUserInputWithoutTime();

		if (inputWithoutLocationDateAndTime.isEmpty()) {
			return null;
		} else {
			return inputWithoutLocationDateAndTime.trim();
		}
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces in the
	 * userInput
	 * 
	 * @return string without extra spaces
	 */
	public String cleanUp() {
		String input = getUserInput();
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		setUserInput(input);
		return input;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces
	 * 
	 * @param input
	 *            string to be cleaned up
	 * @return string without extra spaces
	 */
	public static String cleanUp(String input) {
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		return input;
	}

	/**
	 * Removes the first word of input
	 * 
	 * @param input
	 *            string whose first word is to be removed
	 * @return input without the first word
	 */
	public String removeFirstWord(String input) {
		try {
			return input.split(Constants.SPACE, 2)[Constants.INDEX_2ND_PART];
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns the word immediately before the quotation mark whose index is
	 * specified
	 * 
	 * @param indexQuote
	 *            index of quotation mark
	 * @return word immediately before the quotation mark. If there are no words
	 *         before the quotation mark, an empty string is returned.
	 */
	public String getWordBeforeQuote(int indexQuote) {
		String inputUntilQuote = cleanUp(getUserInput().substring(
				Constants.INDEX_BEGIN, indexQuote));
		return getLastWord(inputUntilQuote);
	}

	/**
	 * Returns the last word of a string
	 * 
	 * @param str
	 *            string whose last word is to be returned
	 * @return last word of the string
	 */
	public String getLastWord(String str) {
		try {
			str = cleanUp(str);
			int indexOfLastSpace = str.lastIndexOf(Constants.SPACE_CHAR);

			if (indexOfLastSpace >= Constants.LIMIT_ZERO) {
				return str.substring(indexOfLastSpace).trim();
			} else {
				assert indexOfLastSpace == Constants.NOT_FOUND;
				return str;
			}
		} catch (Exception e) {
			return Constants.EMPTY_STRING;
		}
	}

	/**
	 * Removes double quotes, words within double quotes and the preceding
	 * keyword "at" if any
	 * 
	 * @param input
	 *            String from which words within quotes are to be removed
	 * @return input without double quotes, words within double quotes and the
	 *         preceding keyword "at" if any
	 */
	public String removeWordsWithinQuotes(String input) {
		cleanUp();
		input = cleanUp(input);

		int countDoubleQuotes = countNumberOfDoubleQuotes();
		Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
		Matcher m = p.matcher(input);

		if (countDoubleQuotes == 0) {
			return input;
		} else if (countDoubleQuotes == 2) {
			int startQuoteIndex = 0, endQuoteIndex = 0, count = 0;
			while (m.find()) {
				count++;
				if (count == 1) {
					startQuoteIndex = m.start();
				} else {
					assert count == 2;
					endQuoteIndex = m.start();
				}
			}
			String wordsWithinQuotes = input.substring(startQuoteIndex + 1,
					endQuoteIndex);
			String stringToRemove = Constants.DOUBLE_QUOTE + wordsWithinQuotes
					+ Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(startQuoteIndex).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemove = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemove;
			}
			return cleanUp(input.replaceAll(stringToRemove,
					Constants.EMPTY_STRING));
		} else {
			assert countDoubleQuotes == 4;
			int firstQuoteStart = 0, firstQuoteEnd = 0, secondQuoteStart = 0, secondQuoteEnd = 0, count = 0;
			while (m.find()) {
				count++;
				if (count == 1) {
					firstQuoteStart = m.start();
				} else if (count == 2) {
					firstQuoteEnd = m.start();
				} else if (count == 3) {
					secondQuoteStart = m.start();
				} else {
					assert count == 4;
					secondQuoteEnd = m.start();
				}
			}

			// first 2 double quotes
			String wordsWithinFirstQuotes = input.substring(
					firstQuoteStart + 1, firstQuoteEnd);
			String stringToRemoveFromFirstQuotes = Constants.DOUBLE_QUOTE
					+ wordsWithinFirstQuotes + Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(firstQuoteStart).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemoveFromFirstQuotes = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemoveFromFirstQuotes;
			}

			// next 2 double quotes
			String wordsWithinSecondQuotes = input.substring(
					secondQuoteStart + 1, secondQuoteEnd);
			String stringToRemoveFromSecondQuotes = Constants.DOUBLE_QUOTE
					+ wordsWithinSecondQuotes + Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(secondQuoteStart).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemoveFromSecondQuotes = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemoveFromSecondQuotes;
			}

			String temp = cleanUp(input.replaceAll(
					stringToRemoveFromFirstQuotes, Constants.EMPTY_STRING));
			temp = cleanUp(temp.replaceAll(stringToRemoveFromSecondQuotes,
					Constants.EMPTY_STRING));
			return temp;
		}
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\DescriptionParser.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\DescriptionParserTest.java
	 */


package parser;

import static org.junit.Assert.*;

import org.junit.Test;

public class DescriptionParserTest {

	@Test
	public void testGetDescription() throws Exception {
		DescriptionParser dp = new DescriptionParser(
				"add at home on mon do something 8-10pm");
		assertEquals("do something", dp.getDescription());
		DescriptionParser dp1 = new DescriptionParser(
				"add eat 3 pizzas 3 nov at 3 new street 3 pm");
		assertEquals("eat 3 pizzas", dp1.getDescription());
		DescriptionParser dp2 = new DescriptionParser(
				"add today from 9 am-9 pm write 9 pages homework at 9 th room");
		assertEquals("write 9 pages homework", dp2.getDescription());
		DescriptionParser dp3 = new DescriptionParser("add sleep at 12.20am");
		assertEquals("sleep", dp3.getDescription());
		DescriptionParser dp4 = new DescriptionParser(
				"add at \"home\" \"sleep\"  at 12.20am");
		assertEquals("sleep", dp4.getDescription());
		DescriptionParser dp5 = new DescriptionParser("add hello at \"mon\"");
		assertEquals("hello", dp5.getDescription());
	}

	@Test
	public void testRemoveWordsWithinQuotes() {
		DescriptionParser dp = new DescriptionParser("add hello at \"mon\"");
		assertEquals("add hello",
				dp.removeWordsWithinQuotes("add hello at \"mon\""));
		DescriptionParser dp1 = new DescriptionParser(
				"add on tue \"hello world\" at \"mon\"");
		assertEquals(
				"add on tue",
				dp1.removeWordsWithinQuotes("add on tue \"hello world\" at \"mon\""));
	}

	@Test
	public void testRemoveFirstWord() {
		DescriptionParser dp = new DescriptionParser("abc");
		assertEquals("two three four", dp.removeFirstWord("one two three four"));
	}

	@Test
	public void testGetDescriptionForEdit() throws Exception {
		DescriptionParser dp = new DescriptionParser("do something 8-10pm");
		assertEquals("do something", dp.getDescriptionForEdit());
		DescriptionParser dp3 = new DescriptionParser(
				"\"must do something\" 8-10pm");
		assertEquals("must do something", dp3.getDescriptionForEdit());
		DescriptionParser dp1 = new DescriptionParser("at post office");
		assertEquals(null, dp1.getDescriptionForEdit());
		DescriptionParser dp2 = new DescriptionParser("11 dec 8-10pm");
		assertEquals(null, dp2.getDescriptionForEdit());
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\DescriptionParserTest.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\IndexParser.java
	 */


/**
 * This class parses individual task indexes and index ranges.
 * 
 */

package parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import lol.Constants;

public class IndexParser {

	/************* Attribute ***************/
	private String userInput;

	/************* Constructor ***************/
	public IndexParser(String userInput) {
		setUserInput(userInput);
	}

	/************* Accessor ***************/
	public String getUserInput() {
		return userInput;
	}

	/************* Mutator ***************/
	public void setUserInput(String userInput) {
		this.userInput = userInput;
	}

	/************* Other methods ***************/
	/**
	 * Removes multiple spaces between words, leading and trailing spaces in the
	 * userInput
	 * 
	 * @return string without extra spaces
	 */
	public String cleanUp() {
		String input = getUserInput();
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		setUserInput(input);
		return input;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces
	 * 
	 * @param input
	 *            string to be cleaned up
	 * @return string without extra spaces
	 */
	public String cleanUp(String input) {
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		return input;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces for
	 * all strings in an array
	 * 
	 * @param input
	 *            array containing strings to be formatted
	 * @return array with formatted strings
	 */
	public String[] cleanUp(String[] input) {
		for (int i = 0; i < input.length; i++) {
			String temp = input[i];
			temp = temp.trim();
			temp = cleanUp(temp);
			input[i] = temp;
		}
		return input;
	}

	/**
	 * Removes the first word of the input and returns the resulting string
	 * 
	 * @param input
	 *            Input string
	 * @return Input string without the first word
	 */
	public String removeFirstWord(String input) {
		try {
			return input.split(Constants.SPACE, 2)[Constants.INDEX_2ND_PART];
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Removes the command name from the user input and returns the resulting
	 * string
	 * 
	 * @param input
	 *            Input string
	 * @return Input string without the command name
	 */
	public String removeCommandName(String userInput) {
		return removeFirstWord(userInput);
	}

	/**
	 * Returns an array of task indices for delete/done commands, counting from
	 * 1.
	 * 
	 * @param input
	 *            user input
	 * @return array of task indices. If any index is not an integer or no index
	 *         is found, null is returned.
	 */
	public int[] getTaskIndexArray() {
		try {
			String input = cleanUp();
			String inputWithoutCommand = cleanUp(removeFirstWord(input));

			/* individual indices are separated by space e.g delete 1 4 6 */
			int[] indexSeparatedBySpace = getIndexSeparatedBySpace(inputWithoutCommand);
			if (indexSeparatedBySpace != null) {
				return removeDuplicates(indexSeparatedBySpace);
			}

			/* individual indices are separated by comma e.g delete 1,4,6 */
			int[] indexSeparatedByComma = getIndexSeparatedByComma(inputWithoutCommand);
			if (indexSeparatedByComma != null) {
				return removeDuplicates(indexSeparatedByComma);
			}

			/*
			 * index ranges may be mixed with individual indexes and are
			 * separated by comma e.g delete 1-4, 6
			 */
			String[] indexRanges = getIndexRangesSeparatedByComma(inputWithoutCommand);
			ArrayList<Integer> indexesToDelete = new ArrayList<Integer>();

			for (String indexRange : indexRanges) {
				if (isInteger(indexRange)) {
					// single index
					indexesToDelete.add(Integer.parseInt(indexRange));
				} else {
					// index range
					int start = getStartIndex(indexRange);
					int end = getEndIndex(indexRange);

					while (start <= end) {
						indexesToDelete.add(start);
						start++;
					}
				}
			}

			int[] outputArr = removeDuplicates(buildIntArray(indexesToDelete));
			if (outputArr.length == 1
					&& outputArr[Constants.INDEX_BEGIN] == Constants.NOT_FOUND) {
				return null;
			} else {
				return outputArr;
			}
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns an array of task indexes for an input where individual indices
	 * are separated by space. Example: delete 1 2 3 returns {1, 2, 3}
	 * 
	 * @param input
	 *            user input without command name. Example: 1 2 3
	 * @return array of task indices if input format is valid, else returns null
	 */
	public int[] getIndexSeparatedBySpace(String userInputWithoutCommand) {
		try {
			String input = cleanUp(userInputWithoutCommand);
			String[] words = input.split(Constants.SPACE);
			int[] index = new int[words.length];

			for (int i = 0; i < words.length; i++) {
				index[i] = Integer.parseInt(words[i].trim());
			}
			return index;

		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns an array of task indexes for an input where individual indices
	 * are separated by comma. Spaces before and after commas are ignored.
	 * Example: delete 1,2,3 returns {1, 2, 3}
	 * 
	 * @param input
	 *            user input without command name. Example: 1,2,3
	 * @return array of task indices if input format is valid, else returns null
	 */
	public int[] getIndexSeparatedByComma(String userInputWithoutCommand) {
		try {
			String input = cleanUp(userInputWithoutCommand);
			String[] words = input.split(Constants.COMMA);
			int[] index = new int[words.length];

			for (int i = 0; i < words.length; i++) {
				index[i] = Integer.parseInt(words[i].trim());
			}
			return index;

		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns an array of task index ranges for an input where index ranges are
	 * separated by space. Example: delete 1-3, 4, 6 to 9 returns {1-3, 4, 6 to
	 * 9}
	 * 
	 * @param input
	 *            user input without command name. Example: 1-3, 4, 6 to 9
	 * @return array of task index ranges if input format is valid, else returns
	 *         null
	 */
	public String[] getIndexRangesSeparatedByComma(
			String userInputWithoutCommand) {
		try {
			String input = cleanUp(userInputWithoutCommand);
			return cleanUp(input.split(Constants.COMMA));
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns the start index of an index range. Example: 6 to 9 returns 6, 1-3
	 * returns 1
	 * 
	 * @param range
	 *            index range
	 * @return start index of the range
	 */
	public int getStartIndex(String range) {
		try {
			// replace all non-digits with space
			return getIndexSeparatedBySpace(range.replaceAll(
					Constants.REGEX_NON_DIGIT, Constants.SPACE))[Constants.INDEX_START];
		} catch (Exception e) {
			return Constants.NOT_FOUND;
		}
	}

	/**
	 * Returns the starting index of an index range. Example: 6 to 9 returns 9,
	 * 1-3 returns 3
	 * 
	 * @param range
	 *            index range
	 * @return end index of the range
	 */
	public int getEndIndex(String range) {
		try {
			// replace all non-digits with space
			return getIndexSeparatedBySpace(range.replaceAll(
					Constants.REGEX_NON_DIGIT, Constants.SPACE))[Constants.INDEX_END];
		} catch (Exception e) {
			return Constants.NOT_FOUND;
		}
	}

	/**
	 * Creates an integer array from an arraylist of integers
	 * 
	 * @param integersList
	 *            arraylist of integers
	 * @return array of integers
	 */
	public int[] buildIntArray(ArrayList<Integer> integersList) {
		int[] integersArray = new int[integersList.size()];
		int i = 0;
		for (Integer n : integersList) {
			integersArray[i++] = n;
		}
		return integersArray;
	}

	/**
	 * Checks whether a string is an integer
	 * 
	 * @param s
	 *            string to be checked
	 * @return true if the string is an integer, else false
	 */
	public boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
	}

	/**
	 * Removes duplicate elements from an integer array
	 * 
	 * @param arr
	 *            array in which duplicates are to be removed
	 * @return array without duplicates sorted in ascending order
	 */
	public int[] removeDuplicates(int[] arr) {
		ArrayList<Integer> integers = new ArrayList<Integer>();
		int length = arr.length;

		Set<Integer> set = new HashSet<Integer>();

		for (int i = 0; i < length; i++) {
			set.add(arr[i]);
		}

		Iterator<Integer> it = set.iterator();
		while (it.hasNext()) {
			integers.add(it.next());
		}
		int[] intArray = buildIntArray(integers);
		Arrays.sort(intArray);
		return intArray;
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\IndexParser.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\IndexParserTest.java
	 */


package parser;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

public class IndexParserTest {

	@Test
	public void testRemoveFirstWord() {
		IndexParser ip = new IndexParser("abc");
		assertEquals("1,2, 4", ip.removeFirstWord("delete 1,2, 4"));
		assertEquals("3 5 7", ip.removeFirstWord("delete 3 5 7"));
	}

	@Test
	public void testRemoveCommandName() {
		IndexParser ip = new IndexParser("abc");
		assertEquals("1,2, 4", ip.removeFirstWord("rm 1,2, 4"));
		assertEquals("3 5 7", ip.removeFirstWord("del 3 5 7"));
	}

	@Test
	public void testGetTaskIndexArray() {
		IndexParser ip1 = new IndexParser("rm 1 2 3");
		int[] arr1 = { 1, 2, 3 };
		assertArrayEquals(arr1, ip1.getTaskIndexArray());

		IndexParser ip2 = new IndexParser("rm 7,1,9");
		int[] arr2 = { 1, 7, 9 };
		assertArrayEquals(arr2, ip2.getTaskIndexArray());

		IndexParser ip3 = new IndexParser("rm 5-8");
		int[] arr3 = { 5, 6, 7, 8 };
		assertArrayEquals(arr3, ip3.getTaskIndexArray());

		IndexParser ip4 = new IndexParser("delete 2-7, 10");
		int[] arr4 = { 2, 3, 4, 5, 6, 7, 10 };
		assertArrayEquals(arr4, ip4.getTaskIndexArray());

		IndexParser ip5 = new IndexParser("delete 1-3, 19, 20-23");
		int[] arr5 = { 1, 2, 3, 19, 20, 21, 22, 23 };
		assertArrayEquals(arr5, ip5.getTaskIndexArray());

		IndexParser ip6 = new IndexParser("delete 1-3, 19 to 22, 20-23");
		int[] arr6 = { 1, 2, 3, 19, 20, 21, 22, 23 };
		assertArrayEquals(arr6, ip6.getTaskIndexArray());
	}

	@Test
	public void testGetIndexSeparatedBySpace() {
		IndexParser ip = new IndexParser("abc");
		int[] arr = { 1, 7, 8 };
		assertArrayEquals(arr, ip.getIndexSeparatedBySpace("1 7 8"));
	}

	@Test
	public void testGetIndexSeparatedByComma() {
		IndexParser ip = new IndexParser("abc");
		int[] arr = { 12, 13, 18 };
		assertArrayEquals(arr, ip.getIndexSeparatedByComma("12,13,18"));
		assertArrayEquals(arr, ip.getIndexSeparatedByComma("12, 13, 18"));
	}

	@Test
	public void testGetIndexRangesSeparatedByComma() {
		IndexParser ip = new IndexParser("abc");
		String[] arr = { "5-8", "10" };
		assertArrayEquals(arr, ip.getIndexRangesSeparatedByComma("5-8, 10"));
	}

	@Test
	public void testGetStartIndex() {
		IndexParser ip = new IndexParser("abc");
		assertEquals(6, ip.getStartIndex("6-9"));
		assertEquals(11, ip.getStartIndex("11 to 18"));
	}

	@Test
	public void testGetEndIndex() {
		IndexParser ip = new IndexParser("abc");
		assertEquals(9, ip.getEndIndex("6-9"));
		assertEquals(18, ip.getEndIndex("11 to 18"));
	}

	@Test
	public void testBuildIntArray() {
		IndexParser ip = new IndexParser("abc");
		int[] arr = { 1, 2, 3 };
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(1);
		al.add(2);
		al.add(3);
		assertArrayEquals(arr, ip.buildIntArray(al));
	}

	@Test
	public void testIsInteger() {
		IndexParser ip = new IndexParser("abc");
		assertTrue(ip.isInteger("7"));
		assertFalse(ip.isInteger("p"));
	}

	@Test
	public void testRemoveDuplicates() {
		IndexParser ip = new IndexParser("abc");
		int[] arr1 = { 1, 5, 9 };
		int[] arr2 = { 5, 1, 1, 1, 5, 5, 9 };
		assertArrayEquals(arr1, ip.removeDuplicates(arr2));
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\IndexParserTest.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\LocationParser.java
	 */


/**
 * This class parses the location of a task.
 * 
 */
package parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lol.Constants;

public class LocationParser {
	/************* Attribute ***************/
	private String userInput;

	/************* Constructor ***************/
	public LocationParser(String userInput) {
		this.userInput = userInput;
	}

	/************* Accessor ***************/
	public String getUserInput() {
		return userInput;
	}

	/************* Mutator ***************/
	public void setUserInput(String userInput) {
		this.userInput = userInput;
	}

	/************* Other methods ***************/
	/**
	 * Returns the location from the user input
	 * 
	 * @return location if it exists, else null
	 */
	public String getLocation() {
		try {
			cleanUp();
			String input = getUserInput();

			// check for double quotes
			Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
			Matcher m = p.matcher(input);

			int countDoubleQuotes = countNumberOfDoubleQuotes();

			// only location and description can be enclosed in double quotes
			// more than 4 quotes and odd number of quotes are invalid
			if (countDoubleQuotes % 2 == 1 || countDoubleQuotes > 4) {
				throw new Exception(Constants.FEEDBACK_INVALID_NUMBER_OF_QUOTES);
			}

			if (countDoubleQuotes == 2) { // one parameter within quotes
				int startQuoteIndex = 0, endQuoteIndex = 0, count = 0;
				while (m.find()) {
					count++;
					if (count == 1) {
						startQuoteIndex = m.start();
					} else {
						assert count == 2;
						endQuoteIndex = m.start();
					}
				}

				/*
				 * if word preceding the quote is "at", the quote encloses a
				 * location, else it contains a description
				 */
				if (getWordBeforeQuote(startQuoteIndex).equalsIgnoreCase(
						Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
					return cleanUp(input.substring(startQuoteIndex + 1,
							endQuoteIndex));
				}

			} else if (countDoubleQuotes == 4) { // two parameters within quotes

				int firstQuoteStart = 0, firstQuoteEnd = 0, secondQuoteStart = 0, secondQuoteEnd = 0, count = 0;
				while (m.find()) {
					count++;
					if (count == 1) {
						firstQuoteStart = m.start();
					} else if (count == 2) {
						firstQuoteEnd = m.start();
					} else if (count == 3) {
						secondQuoteStart = m.start();
					} else {
						assert count == 4;
						secondQuoteEnd = m.start();
					}
				}

				/*
				 * if word preceding the quote is "at", the quote encloses a
				 * location, else it contains a description
				 */
				if (getWordBeforeQuote(firstQuoteStart).equalsIgnoreCase(
						Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
					return cleanUp(input.substring(firstQuoteStart + 1,
							firstQuoteEnd));
				}

				if (getWordBeforeQuote(secondQuoteStart).equalsIgnoreCase(
						Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
					return cleanUp(input.substring(secondQuoteStart + 1,
							secondQuoteEnd));
				}
			}

			/*
			 * either no double quotes in input or no location found within
			 * double quotes
			 */
			input = removeWordsWithinQuotes(input);
			setUserInput(input);

			TimeParser tp = new TimeParser();
			DateParser dp = new DateParser();

			if (countNumberOfAt(input) == 1) {
				String parameter = getParameterStartingAtIndex(getIndexOfAt()
						+ Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT]
								.length() + 1);
				parameter = removeDescriptionAfterTimeIfAny(parameter);

				if (!tp.isValidTimeFormat(parameter)
						&& !dp.isValidDateFormat(parameter)) {
					return parameter;
				} else {
					return null;
				}
			} else {
				Pattern pAt = Pattern
						.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_AT]);
				Matcher mAt = pAt.matcher(getUserInput());

				while (mAt.find()) {
					String parameter = getParameterStartingAtIndex(mAt.end() + 1);
					parameter = removeDescriptionAfterTimeIfAny(parameter);
					if (!tp.isValidTimeFormat(parameter)
							&& !dp.isValidDateFormat(parameter)) {
						return parameter;
					}
				}
				return null;
			}
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns user input excluding the location and the keyword "at" preceding
	 * it
	 * 
	 * @return user input excluding the location and the keyword "at" preceding
	 *         it
	 */
	public String getUserInputWithoutLocation() {
		cleanUp();
		String output = userInput.replaceAll(
				Constants.REGEX_AT_SPACE_WORD_START + getLocation()
						+ Constants.REGEX_WORD_END, Constants.EMPTY_STRING);
		return cleanUp(output);
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces in the
	 * userInput
	 * 
	 * @return string without extra spaces
	 */
	public String cleanUp() {
		String input = getUserInput();
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		setUserInput(input);
		return input;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces
	 * 
	 * @param input
	 *            string to be cleaned up
	 * @return string without extra spaces
	 */
	public String cleanUp(String input) {
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		return input;
	}

	/**
	 * Counts number of "at" in input
	 * 
	 * @param input
	 *            string in which number of 'at's are to be counted
	 * @return number of "at" in userInput
	 */
	public int countNumberOfAt(String input) {
		Pattern p = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_AT]);
		Matcher m = p.matcher(input);

		int count = 0;
		while (m.find()) {
			count++;
		}
		return count;
	}

	/**
	 * Returns a parameter (e.g location, due date) starting from 'index' till
	 * the occurrence of another reserved word or the end of the string,
	 * whichever is earlier
	 * 
	 * @param index
	 *            index of userInput at which the parameter to be returned
	 *            starts
	 * @return parameter starting from index
	 */
	public String getParameterStartingAtIndex(int index) {
		if (isIndexOutOfBounds(index)) {
			return null;
		}
		String stringToCheck = getUserInput().substring(index);
		int nextSpaceIndex = stringToCheck.indexOf(Constants.SPACE_CHAR);

		int nextSpaceIndexInOriginalString;

		if (nextSpaceIndex == Constants.NOT_FOUND) {
			nextSpaceIndexInOriginalString = Constants.NOT_FOUND;
		} else {
			nextSpaceIndexInOriginalString = nextSpaceIndex + index;
		}

		int nextKeywordIndex;

		if (nextSpaceIndexInOriginalString == Constants.NOT_FOUND) {
			nextKeywordIndex = Constants.NOT_FOUND;
		} else {
			nextKeywordIndex = getIndexOfNextReservedWord(nextSpaceIndexInOriginalString);
		}

		if (nextKeywordIndex == Constants.NOT_FOUND) {
			return getUserInput().substring(index).trim();
		} else {
			assert nextKeywordIndex > 0;
			return getUserInput().substring(index, nextKeywordIndex).trim();
		}
	}

	/**
	 * Returns the starting index of the next keyword
	 * 
	 * @param beginIndex
	 *            index of userInput to start searching from
	 * @return starting index of next keyword, -1 if not found
	 */
	public int getIndexOfNextReservedWord(int beginIndex) {
		String temp = getUserInput().substring(beginIndex);
		String[] words = temp.split(Constants.SPACE);
		int minIndex = Constants.NOT_FOUND;

		for (int i = 0; i < words.length; i++) {
			String word = words[i];
			/*
			 * find next 4 words because date and time formats (excluding date
			 * range) can have at most 5 words
			 */
			String[] nextWords = { Constants.EMPTY_STRING,
					Constants.EMPTY_STRING, Constants.EMPTY_STRING,
					Constants.EMPTY_STRING };

			if (i < words.length - 4) {
				int index = 0;
				while (index < 4) {
					nextWords[index] = words[i + 1 + index];
					index++;
				}
			} else if (i < words.length - 3) {
				int index = 0;
				while (index < 3) {
					nextWords[index] = words[i + 1 + index];
					index++;
				}
			} else if (i < words.length - 2) {
				int index = 0;
				while (index < 2) {
					nextWords[index] = words[i + 1 + index];
					index++;
				}
			} else if (i < words.length - 1) {
				int index = 0;
				while (index < 1) {
					nextWords[index] = words[i + 1 + index];
					index++;
				}
			} else {
				assert i == words.length - 1;
			}

			if (isReservedWord(word)
					|| hasDate(word, nextWords)
					|| (hasTime(word, nextWords) && !(word
							.startsWith(Constants.STRING_ZERO) && word
							.endsWith(Constants.STRING_M_LOWERCASE)))) {
				Pattern p = Pattern.compile(Constants.REGEX_WORD_START + word
						+ Constants.REGEX_WORD_END);
				Matcher m = p.matcher(temp);

				if (m.find()) {
					int keywordIndex = m.start() + beginIndex;
					if (minIndex == Constants.NOT_FOUND
							|| keywordIndex < minIndex) {
						minIndex = keywordIndex;
					}
				}
			}
		}
		return minIndex;
	}

	/**
	 * Checks whether the word and the next 4 words form a valid date
	 * 
	 * @param word
	 *            first word
	 * @param nextWords
	 *            second to fifth words, if there are less than 4 elements,
	 *            empty strings are entered for the array element
	 * @return true if word and nextWords contain a valid date, else false
	 */
	public boolean hasDate(String word, String[] nextWords) {
		DateParser dp = new DateParser();
		try {
			return dp.isValidDateFormat(word)
					|| dp.isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD])
					|| dp.isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD])
					|| dp.isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD])
					|| dp.isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]);
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks whether the word and the next 4 words form a valid time or time
	 * range
	 * 
	 * @param word
	 *            first word
	 * @param nextWords
	 *            second to fifth words, if there are less than 4 elements,
	 *            empty strings are entered for the array element
	 * @return true if word and nextWords contain a valid time format, else
	 *         false
	 */
	public boolean hasTime(String word, String[] nextWords) {
		TimeParser tp = new TimeParser();
		try {
			return tp.isValidTimeFormat(word)
					|| tp.isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD])
					|| tp.isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD])
					|| tp.isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD])
					|| tp.isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]);
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks is a word is a keyword (at, by etc.) or reserved word (days of the
	 * week, today, tomorrow, tmw)
	 * 
	 * @param word
	 *            word to be checked
	 * @return true if a word is a keyword or reserved word, else false
	 */
	public boolean isReservedWord(String word) {
		return hasWordInDictionary(Constants.KEYWORDS, word)
				|| hasWordInDictionary(Constants.DAYS_IMMEDIATE, word)
				|| hasWordInDictionary(Constants.DAYS_LONG, word)
				|| hasWordInDictionary(Constants.DAYS_SHORT, word);
	}

	/**
	 * Returns the index of first occurrence of the word "at" in userInput
	 * 
	 * @return index of first occurrence of the word "at" in userInput
	 */
	public int getIndexOfAt() {
		Pattern p = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_AT]);
		Matcher m = p.matcher(userInput);

		if (m.find()) {
			return m.start();
		} else {
			return Constants.NOT_FOUND;
		}
	}

	/**
	 * Checks whether index is out of bounds for userInput
	 * 
	 * @param index
	 *            index to be checked
	 * @return true if index out of bounds, else false
	 */
	public boolean isIndexOutOfBounds(int index) {
		return index < Constants.LIMIT_ZERO || index >= getUserInput().length();
	}

	/**
	 * Check whether a word appears in a dictionary
	 * 
	 * @param dictionary
	 *            Dictionary to be searched
	 * @param word
	 *            Word to search for
	 * @return true if word appears in dictionary, false otherwise
	 */
	public boolean hasWordInDictionary(String[] dictionary, String word) {
		word = word.trim();
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(word)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Returns the number of double quotes(") in the userInput
	 * 
	 * @return number of double quotes(") in the userInput
	 */
	public int countNumberOfDoubleQuotes() {
		Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
		Matcher m = p.matcher(getUserInput());

		int count = 0;
		while (m.find()) {
			count++;
		}
		return count;
	}

	/**
	 * Returns the word immediately before the quotation mark whose index is
	 * specified
	 * 
	 * @param indexQuote
	 *            index of quotation mark
	 * @return word immediately before the quotation mark. If there are no words
	 *         before the quotation mark, an empty string is returned.
	 */
	public String getWordBeforeQuote(int indexQuote) {
		String inputUntilQuote = cleanUp(getUserInput().substring(
				Constants.INDEX_BEGIN, indexQuote));
		return getLastWord(inputUntilQuote);
	}

	/**
	 * Returns the last word of a string
	 * 
	 * @param str
	 *            string whose last word is to be returned
	 * @return last word of the string
	 */
	public String getLastWord(String str) {
		try {
			str = cleanUp(str);
			int indexOfLastSpace = str.lastIndexOf(Constants.SPACE_CHAR);

			if (indexOfLastSpace >= Constants.LIMIT_ZERO) {
				return str.substring(indexOfLastSpace).trim();
			} else {
				assert indexOfLastSpace == Constants.NOT_FOUND;
				return str;
			}
		} catch (Exception e) {
			return Constants.EMPTY_STRING;
		}
	}

	/**
	 * Removes double quotes, words within double quotes and the preceding
	 * keyword "at" if any
	 * 
	 * @param input
	 *            String from which words within quotes are to be removed
	 * @return input without double quotes, words within double quotes and the
	 *         preceding keyword "at" if any
	 */
	public String removeWordsWithinQuotes(String input) {
		cleanUp();
		input = cleanUp(input);

		int countDoubleQuotes = countNumberOfDoubleQuotes();
		Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
		Matcher m = p.matcher(input);

		if (countDoubleQuotes == 0) {
			return input;
		} else if (countDoubleQuotes == 2) {
			int startQuoteIndex = 0, endQuoteIndex = 0, count = 0;
			while (m.find()) {
				count++;
				if (count == 1) {
					startQuoteIndex = m.start();
				} else {
					assert count == 2;
					endQuoteIndex = m.start();
				}
			}
			String wordsWithinQuotes = input.substring(startQuoteIndex + 1,
					endQuoteIndex);
			String stringToRemove = Constants.DOUBLE_QUOTE + wordsWithinQuotes
					+ Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(startQuoteIndex).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemove = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemove;
			}
			return cleanUp(input.replaceAll(stringToRemove,
					Constants.EMPTY_STRING));
		} else {
			assert countDoubleQuotes == 4;
			int firstQuoteStart = 0, firstQuoteEnd = 0, secondQuoteStart = 0, secondQuoteEnd = 0, count = 0;
			while (m.find()) {
				count++;
				if (count == 1) {
					firstQuoteStart = m.start();
				} else if (count == 2) {
					firstQuoteEnd = m.start();
				} else if (count == 3) {
					secondQuoteStart = m.start();
				} else {
					assert count == 4;
					secondQuoteEnd = m.start();
				}
			}

			// first 2 double quotes
			String wordsWithinFirstQuotes = input.substring(
					firstQuoteStart + 1, firstQuoteEnd);
			String stringToRemoveFromFirstQuotes = Constants.DOUBLE_QUOTE
					+ wordsWithinFirstQuotes + Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(firstQuoteStart).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemoveFromFirstQuotes = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemoveFromFirstQuotes;
			}

			// next 2 double quotes
			String wordsWithinSecondQuotes = input.substring(
					secondQuoteStart + 1, secondQuoteEnd);
			String stringToRemoveFromSecondQuotes = Constants.DOUBLE_QUOTE
					+ wordsWithinSecondQuotes + Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(secondQuoteStart).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemoveFromSecondQuotes = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemoveFromSecondQuotes;
			}

			String temp = cleanUp(input.replaceAll(
					stringToRemoveFromFirstQuotes, Constants.EMPTY_STRING));
			temp = cleanUp(temp.replaceAll(stringToRemoveFromSecondQuotes,
					Constants.EMPTY_STRING));
			return temp;
		}
	}

	/**
	 * Removes task description after a time, if any
	 * 
	 * @param date
	 *            String containing a time which may or may not be followed by a
	 *            task description
	 * @return due date as a string
	 */
	public String removeDescriptionAfterTimeIfAny(String time) {
		String[] words = time.split(Constants.SPACE);
		String firstWord = words[Constants.INDEX_BEGIN];
		String[] nextWords = getNext4Words(words, Constants.INDEX_BEGIN);
		TimeParser tp = new TimeParser();

		if (tp.isValidTimeFormat(firstWord)
				&& !(isPartOfTimeFormat(nextWords[Constants.INDEX_2ND_WORD]))) {
			return firstWord.trim();
		} else if (tp.isValidTimeFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD])
				&& !(isPartOfTimeFormat(nextWords[Constants.INDEX_3RD_WORD]))) {
			return (firstWord + Constants.SPACE + nextWords[Constants.INDEX_2ND_WORD])
					.trim();
		} else if (tp.isValidTimeFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_3RD_WORD])
				&& !(isPartOfTimeFormat(nextWords[Constants.INDEX_4TH_WORD]))) {
			return (firstWord + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE + nextWords[Constants.INDEX_3RD_WORD])
					.trim();
		} else if (tp.isValidTimeFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_4TH_WORD])
				&& !(isPartOfTimeFormat(nextWords[Constants.INDEX_5TH_WORD]))) {
			return (firstWord + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE + nextWords[Constants.INDEX_4TH_WORD])
					.trim();
		} else {
			return (firstWord + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE + nextWords[Constants.INDEX_5TH_WORD])
					.trim();
		}
	}

	/**
	 * Returns true if a word is a part of a time format
	 * 
	 * @param word
	 *            word to be checked
	 * @return true if the word is a part of a time format, else false
	 */
	public boolean isPartOfTimeFormat(String word) {
		word = word.trim();
		return word.equalsIgnoreCase(Constants.STRING_AM)
				|| word.equalsIgnoreCase(Constants.STRING_PM)
				|| word.equalsIgnoreCase(Constants.SEPARATOR_TO)
				|| word.equalsIgnoreCase(Constants.SEPARATOR_DASH);
	}

	/**
	 * Returns the next 4 words of userInput, starting from the index i + 1
	 * 
	 * @param words
	 *            Array of words in userInput
	 * @param i
	 *            The index of the first word
	 * @return The next 4 words after index i. If there are less than 4 words,
	 *         the empty words are represented by empty strings
	 */
	public String[] getNext4Words(String[] words, int i) {
		String[] nextWords = { Constants.EMPTY_STRING, Constants.EMPTY_STRING,
				Constants.EMPTY_STRING, Constants.EMPTY_STRING };

		if (i < words.length - 4) {
			int index = 0;
			while (index < 4) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 3) {
			int index = 0;
			while (index < 3) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 2) {
			int index = 0;
			while (index < 2) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 1) {
			int index = 0;
			while (index < 1) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else {
			assert i == words.length - 1;
		}
		return nextWords;
	}

}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\LocationParser.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\LocationParserTest.java
	 */


package parser;

import static org.junit.Assert.*;
import lol.Constants;

import org.junit.Test;

public class LocationParserTest {

	@Test
	public void testGetLocation() {
		LocationParser lp = new LocationParser(
				"   add    buy pizza at  clementi on 23   oct at   10am   ");
		assertEquals("clementi", lp.getLocation());
		LocationParser lp1 = new LocationParser(
				"   add   buy pizza at 3am  on sun   at  clementi ");
		assertEquals("clementi", lp1.getLocation());
		LocationParser lp2 = new LocationParser(
				"   add    buy pizza  on 23   oct at   10am   ");
		assertEquals(null, lp2.getLocation());
		LocationParser lp3 = new LocationParser("   add    buy pizza    ");
		assertEquals(null, lp3.getLocation());
		LocationParser lp4 = new LocationParser(
				"   add    buy pizza  at jurong  tomorrow  ");
		assertEquals("jurong", lp4.getLocation());
		LocationParser lp5 = new LocationParser(
				"add at clementi 6 oct  buy pizza    ");
		assertEquals("clementi", lp5.getLocation());
		LocationParser lp6 = new LocationParser(
				"add at westside 9am  buy pizza    ");
		assertEquals("westside", lp6.getLocation());
		LocationParser lp7 = new LocationParser("add sleep at 12.20am");
		assertEquals(null, lp7.getLocation());
		LocationParser lp8 = new LocationParser(
				"add sleep at 12.20am at \"sunday hotel\"");
		assertEquals("sunday hotel", lp8.getLocation());
		LocationParser lp9 = new LocationParser("add at 12.20am do");
		assertEquals(null, lp9.getLocation());
		LocationParser lp10 = new LocationParser("add something at 9.05pm");
		assertEquals(null, lp10.getLocation());
	}

	@Test
	public void testRemoveDescriptionAfterTimeIfAny() {
		LocationParser lp = new LocationParser("abc");
		assertEquals("12.20am", lp.removeDescriptionAfterTimeIfAny("12.20am"));
		assertEquals("12.20am",
				lp.removeDescriptionAfterTimeIfAny("12.20am do"));
		assertEquals("12.20 am - 1 pm",
				lp.removeDescriptionAfterTimeIfAny("12.20 am - 1 pm do"));
		assertEquals("12.20 - 1pm",
				lp.removeDescriptionAfterTimeIfAny("12.20 - 1pm do"));
	}

	@Test
	public void testCleanUp() {
		LocationParser lp = new LocationParser(
				"  add buy pizza at   clementi on 23 oct  at   10am  ");
		assertEquals("add buy pizza at clementi on 23 oct at 10am",
				lp.cleanUp());
	}

	@Test
	public void testCountNumberOfAt() {
		LocationParser lp = new LocationParser(
				"add buy pizza at clementi on 23 oct at 10am");
		assertEquals(
				2,
				lp.countNumberOfAt("add buy pizza at clementi on 23 oct at 10am"));
	}

	@Test
	public void testGetParameterStartingAtIndex() {
		LocationParser lp = new LocationParser(
				"add buy pizza at clementi on 23 oct at 10am");
		assertEquals("clementi", lp.getParameterStartingAtIndex(17));
	}

	@Test
	public void testGetIndexOfNextKeyword() {
		LocationParser lp = new LocationParser(
				"add buy pizza at clementi on 23 oct at 10am");
		assertEquals(14, lp.getIndexOfNextReservedWord(0));
		assertEquals(26, lp.getIndexOfNextReservedWord(17));
	}

	@Test
	public void testGetIndexOfAt() {
		LocationParser lp = new LocationParser(
				"add buy pizza at clementi on 23 oct at 10am");
		assertEquals(14, lp.getIndexOfAt());
	}

	@Test
	public void testIsIndexOutOfBounds() {
		LocationParser lp = new LocationParser(
				"add buy pizza at clementi on 23 oct at 10am");
		assertTrue(lp.isIndexOutOfBounds(-1));
		assertTrue(lp.isIndexOutOfBounds(50));
		assertFalse(lp.isIndexOutOfBounds(10));
	}

	@Test
	public void testHasWordInDictionary() {
		LocationParser lp = new LocationParser(
				"add buy pizza at clementi on 23 oct at 10am");
		assertTrue(lp.hasWordInDictionary(Constants.KEYWORDS, "at"));
	}

	@Test
	public void testIsReservedWord() {
		LocationParser lp = new LocationParser("abc");
		assertTrue(lp.isReservedWord("sunday"));
	}

	@Test
	public void testHasDate() {
		LocationParser lp = new LocationParser("abc");
		String[] arr1 = { "nov", "now" };
		assertTrue(lp.hasDate("6", arr1));
		String[] arr2 = { "nov", "now" };
		assertTrue(lp.hasDate("6/10", arr2));
		String[] arr3 = { "october", "15", "16" };
		assertTrue(lp.hasDate("6", arr3));
		String[] arr4 = { "octopus", "15", "16" };
		assertFalse(lp.hasDate("6", arr4));
	}

	@Test
	public void testHasTime() {
		LocationParser lp = new LocationParser("abc");
		String[] arr1 = { "am", "-", "7", "am" };
		assertTrue(lp.hasTime("6", arr1));
		String[] arr2 = { "am", "n" };
		assertTrue(lp.hasTime("6.30", arr2));
		String[] arr3 = { "to", "8.30", "am" };
		assertTrue(lp.hasTime("6am", arr3));
	}

	@Test
	public void testGetUserInputWithoutLocation() {
		LocationParser lp = new LocationParser(
				"  add    buy pizza   at 10am at   clementi on   23 oct ");
		assertEquals("add buy pizza at 10am on 23 oct",
				lp.getUserInputWithoutLocation());
		LocationParser lp2 = new LocationParser(
				"  add    buy pizza   at 10am  on   23 oct ");
		assertEquals("add buy pizza at 10am on 23 oct",
				lp2.getUserInputWithoutLocation());
		LocationParser lp3 = new LocationParser(
				"  add    buy pizza   at 10am  on   21 oct  at clementi");
		assertEquals("add buy pizza at 10am on 21 oct",
				lp3.getUserInputWithoutLocation());
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\LocationParserTest.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\LOLParser.java
	 */


/**
 * This class parses the user input and returns command name
 * 
 * add - returns a Task object with details of task to be added
 * delete, done - returns array of task indexes
 * edit - returns task index and Task object of the new task
 * show - returns Date object of the date specified after 'show' command
 * search - returns keywords to be searched
 * 
 */
package parser;

//import java.util.logging.*;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lol.Constants;
import lol.Date;
import lol.Task;
import lol.Time;

public class LOLParser {
	// private static Logger logger = Logger.getLogger(Constants.LOGGER_PARSER);
	// static FileHandler handler;

	/*********** Methods to return task details ***************/

	/**
	 * Returns the command name. Example: add, delete, show, etc.
	 * 
	 * @param input
	 *            user input
	 * @return command name
	 */
	public static String getCommandName(String input) {
		String command = getFirstWord(input);

		if (hasWordInDictionary(Constants.DICTIONARY_ADD, command)) {
			return Constants.COMMAND_ADD;
		} else if (hasWordInDictionary(Constants.DICTIONARY_DELETE, command)) {
			return Constants.COMMAND_DELETE;
		} else if (hasWordInDictionary(Constants.DICTIONARY_SHOW, command)) {
			return Constants.COMMAND_SHOW;
		} else if (hasWordInDictionary(Constants.DICTIONARY_SEARCH, command)) {
			return Constants.COMMAND_SEARCH;
		} else if (hasWordInDictionary(Constants.DICTIONARY_EDIT, command)) {
			return Constants.COMMAND_EDIT;
		} else if (hasWordInDictionary(Constants.DICTIONARY_DONE, command)) {
			return Constants.COMMAND_DONE;
		} else if (hasWordInDictionary(Constants.DICTIONARY_NOT_DONE, command)) {
			return Constants.COMMAND_NOT_DONE;
		} else if (hasWordInDictionary(Constants.DICTIONARY_UNDO, command)) {
			return Constants.COMMAND_UNDO;
		} else if (hasWordInDictionary(Constants.DICTIONARY_REDO, command)) {
			return Constants.COMMAND_REDO;
		} else if (hasWordInDictionary(Constants.DICTIONARY_VIEW_HOMESCREEN,
				command)) {
			return Constants.COMMAND_VIEW_HOMESCREEN;
		} else if (hasWordInDictionary(Constants.DICTIONARY_EXIT, command)) {
			return Constants.COMMAND_EXIT;
		} else if (hasWordInDictionary(Constants.DICTIONARY_HELP, command)) {
			return Constants.COMMAND_HELP;
		} else {
			return Constants.COMMAND_INVALID;
		}
	}

	/**
	 * Returns a Task object with details given in the parameter for add command
	 * 
	 * @param input
	 *            user input
	 * @return Task added
	 * @throws Exception
	 */
	public static Task getTask(String input) throws Exception {
		input = cleanUp(input);
		if (countWords(input) <= 1) {
			return null;
		}
		String originalInput = input;
		input = input.toLowerCase();

		DescriptionParser dp = new DescriptionParser(input);
		LocationParser lp = new LocationParser(input);
		DateParser dtp = new DateParser(input);
		TimeParser tp = new TimeParser(removeWordsWithinQuotes(input));

		String description = dp.getDescription();
		String location = lp.getLocation();
		Date date = dtp.getDueDate();
		Date endDate = dtp.getEndDate();
		Time startTime = tp.getStartTime();
		Time endTime = tp.getEndTime();

		if ((startTime != null || endTime != null) && date == null) {
			Time currentTime = tp.getCurrentTime();
			if (currentTime.isBefore(startTime)) {
				date = dtp.getTodaysDate();
			} else {
				date = dtp.addDaysToToday(1);
			}
		}
		if (description != null) {
			description = getParameterInOriginalCase(originalInput, description);
		}
		if (location != null) {
			location = getParameterInOriginalCase(originalInput, location);
		}
		return new Task(description, location, date, endDate, startTime,
				endTime);
	}

	/**
	 * Returns a Task object with details given in the parameter for edit
	 * command
	 * 
	 * @param input
	 *            <edit> + <index> + one or more modified or newly added
	 *            parameters for the task, e.g. edit 2 4 nov
	 * @param task
	 *            Task to be edited
	 * @return Task with modified or newly added parameters
	 */
	public static Task getEditTask(String input, Task task) throws Exception {
		try {
			input = cleanUp(input);
			if (countWords(input) <= 2) {
				throw new Exception(
						Constants.FEEDBACK_INVALID_PARAMETERS_FOR_EDIT);
			}

			String originalInput = input;
			input = input.toLowerCase();

			String inputWithoutCommandAndIndex = cleanUp(removeFirst2Words(input));
			Task newTask = task;

			String[] words = inputWithoutCommandAndIndex.split(Constants.SPACE);
			// if the user wants to delete parameters
			if (containsCommand(words, Constants.DICTIONARY_DELETE)) {
				for (int i = 0; i < words.length - 1; i++) {
					// if delete command is found
					if (hasWordInDictionary(Constants.DICTIONARY_DELETE,
							words[i])) {
						int index = i + 1;
						// delete all parameters after 'delete' keyword
						while (index < words.length
								&& hasWordInDictionary(
										Constants.DICTIONARY_PARAMETERS,
										words[index])) {
							switch (words[index]) {

							case Constants.PARAMETER_LOCATION:
							case Constants.PARAMETER_LOC:
								newTask.setLocation(null);
								break;

							case Constants.PARAMETER_DATE:
								newTask.setDueDate(null);
								newTask.setEndDate(null);
								newTask.setStartTime(null);
								newTask.setEndTime(null);
								break;

							case Constants.PARAMETER_START_DATE:
							case Constants.PARAMETER_SD:
								newTask.setDueDate(null);
								newTask.setEndDate(null);
								newTask.setStartTime(null);
								newTask.setEndTime(null);
								break;

							case Constants.PARAMETER_END_DATE:
							case Constants.PARAMETER_ED:
								newTask.setEndDate(null);
								break;

							case Constants.PARAMETER_TIME:
								newTask.setStartTime(null);
								newTask.setEndTime(null);
								break;

							case Constants.PARAMETER_START_TIME:
							case Constants.PARAMETER_ST:
								newTask.setStartTime(null);
								newTask.setEndTime(null);
								break;

							case Constants.PARAMETER_END_TIME:
							case Constants.PARAMETER_ET:
								newTask.setEndTime(null);
								break;

							}
							index++;
						}
					}
				}
				inputWithoutCommandAndIndex = removeDeleteParameters(inputWithoutCommandAndIndex);
			}

			DescriptionParser dp = new DescriptionParser(
					inputWithoutCommandAndIndex);
			LocationParser lp = new LocationParser(inputWithoutCommandAndIndex);
			DateParser dtp = new DateParser(inputWithoutCommandAndIndex);
			TimeParser tp = new TimeParser(inputWithoutCommandAndIndex);

			String description = dp.getDescriptionForEdit();
			String location = lp.getLocation();
			Date startDate = dtp.getDueDate();
			Date endDate = dtp.getEndDate();
			Time startTime = tp.getStartTime();
			Time endTime = tp.getEndTime();

			if (description != null) {
				description = getParameterInOriginalCase(originalInput,
						description);
				newTask.setDescription(description);
			}

			if (location != null) {
				location = getParameterInOriginalCase(originalInput, location);
				newTask.setLocation(location);
			}

			if (startDate != null) {
				newTask.setDueDate(startDate);
			}

			if (endDate != null) {
				newTask.setEndDate(endDate);
			}

			if (startTime != null) {
				newTask.setStartTime(startTime);

				if (newTask.getTaskDueDate() == null) {
					if (startTime.isAfter(tp.getCurrentTime())) {
						// due date is today
						newTask.setDueDate(dtp.getTodaysDate());
					} else {
						// due date is tomorrow
						newTask.setDueDate(dtp.addDaysToToday(1));
					}
				}
			}

			if (endTime != null) {
				newTask.setEndTime(endTime);
			}

			return newTask;
		} catch (Exception e) {
			throw new Exception(Constants.FEEDBACK_INVALID_PARAMETERS_FOR_EDIT);
		}
	}

	/**
	 * Returns index of task for delete/edit/done commands, counting from 1.
	 * Example: 'delete 1' returns 1. If index is not an integer or no the input
	 * does not contain an index, -1 is returned.
	 * 
	 * @param input
	 *            user input
	 * @return index of task if it is in the input and is an integer, else -1
	 */
	public static int getTaskIndex(String input) {
		try {
			// handler = new FileHandler(Constants.LOGGER_FILE_NAME, true);
			// logger.addHandler(handler);
			// handler.setFormatter(new SimpleFormatter());
			return Integer
					.parseInt(input.split(Constants.SPACE)[Constants.INDEX_2ND_PART]);
		} catch (Exception e) {
			// logger.log(Level.WARNING, Constants.ERROR_PROCESSING, e);
			return Constants.NOT_FOUND;
		}
	}

	/**
	 * Returns an array of task indices for delete/done commands, counting from
	 * 1.
	 * 
	 * @param input
	 *            user input
	 * @return array of task indices. If any index is not an integer or no index
	 *         is found, null is returned.
	 */
	public static int[] getTaskIndexArray(String input) {
		try {
			IndexParser ip = new IndexParser(input);
			return ip.getTaskIndexArray();
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns the date entered after show command as a Date object
	 * 
	 * @param input
	 *            user input
	 * @return if the date entered after the command is a valid format then the
	 *         method returns a Date object, else returns null
	 */
	public static Date getDateForShowCommand(String input) {
		try {
			if (countWords(input) <= 1) {
				return null;
			}
			input = cleanUp(input);
			String date = removeFirstWord(input);
			DateParser dp = new DateParser();
			if (dp.isValidDateFormat(date)) {
				return dp.createDate(date);
			} else {
				return null;
			}
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns keywords for search command
	 * 
	 * @param input
	 *            user input
	 * @return Keywords after search command. If the user input contains 1 or no
	 *         words, returns null.
	 */
	public static String getKeywordsForSearchCommand(String input) {
		try {
			input = cleanUp(input);
			if (countWords(input) <= 1) {
				return null;
			} else {
				return removeFirstWord(input);
			}
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Return number of words in a string
	 * 
	 * @param input
	 *            Input string
	 * @return Number of words in input string
	 */
	public static int countWords(String input) {
		input = cleanUp(input);
		return input.split(Constants.SPACE).length;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces
	 * 
	 * @param input
	 *            string to be cleaned up
	 * @return string without extra spaces
	 */
	public static String cleanUp(String input) {
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		return input;
	}

	/**
	 * Remove the first word of the input and returns the resulting string
	 * 
	 * @param input
	 *            Input string
	 * @return Input string without the first word
	 */
	public static String removeFirstWord(String input) {
		try {
			return input.split(Constants.SPACE, 2)[Constants.INDEX_2ND_PART];
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Remove the first 2 words of the input and returns the resulting string
	 * 
	 * @param input
	 *            Input string
	 * @return Input string without the first 2 words
	 */
	public static String removeFirst2Words(String input) {
		try {
			return input.split(Constants.SPACE, 3)[Constants.INDEX_3RD_PART];
		} catch (Exception e) {
			return input;
		}
	}

	/**
	 * Return the first word of the input
	 * 
	 * @param input
	 *            Input string
	 * @return First word of input
	 */
	public static String getFirstWord(String input) {
		try {
			return input.split(Constants.SPACE, 2)[Constants.INDEX_BEGIN];
		} catch (Exception e) {
			return input;
		}
	}

	/**
	 * Check whether a word appears in a dictionary
	 * 
	 * @param dictionary
	 *            Dictionary to be searched
	 * @param word
	 *            Word to search for
	 * @return true if word appears in dictionary, false otherwise
	 */

	public static boolean hasWordInDictionary(String[] dictionary, String word) {
		word = word.trim();
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(word)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Checks whether an array of Strings contains a command in a dictionary
	 * 
	 * @param words
	 *            array to be checked
	 * @param commandDictionary
	 *            all possible formats of the command to be checked
	 * @return true if the array of words contains the command, else false
	 */
	public static boolean containsCommand(String[] words,
			String[] commandDictionary) {
		for (int i = 0; i < words.length; i++) {
			if (hasWordInDictionary(commandDictionary, words[i])) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Removes all delete keywords ('delete', 'd', etc.) and parameters
	 * ('location', 'loc', 'date', etc.) from the input string
	 * 
	 * @param input
	 *            String from which delete keywords and parameters are to be
	 *            removed
	 * @return input without delete keywords and parameters
	 */
	public static String removeDeleteParameters(String input) {
		// Delete the 'delete' keywords
		for (int i = 0; i < Constants.DICTIONARY_DELETE.length; i++) {
			String word = Constants.DICTIONARY_DELETE[i];
			input = cleanUp(input.replaceAll(Constants.REGEX_WORD_START + word
					+ Constants.REGEX_WORD_END, Constants.EMPTY_STRING));
		}

		// Delete parameters
		for (int i = 0; i < Constants.DICTIONARY_PARAMETERS.length; i++) {
			String word = Constants.DICTIONARY_PARAMETERS[i];
			input = cleanUp(input.replaceAll(Constants.REGEX_WORD_START + word
					+ Constants.REGEX_WORD_END, Constants.EMPTY_STRING));
		}
		return input;
	}

	/**
	 * Returns a parameter such as description or location in the case in which
	 * the user entered it
	 * 
	 * @param originalInput
	 *            user input
	 * @param lowercaseParameter
	 *            parameter in lowercase
	 * @return parameter in the original case
	 */
	public static String getParameterInOriginalCase(String originalInput,
			String lowercaseParameter) {
		Pattern p = Pattern.compile(lowercaseParameter,
				Pattern.CASE_INSENSITIVE);
		Matcher m = p.matcher(originalInput);

		int start = 0, end = 0;
		if (m.find()) {
			start = m.start();
			end = m.end();
		}

		return originalInput.substring(start, end);
	}

	/**
	 * Removes double quotes, words within double quotes and the preceding
	 * keyword "at" if any
	 * 
	 * @param input
	 *            String from which words within quotes are to be removed
	 * @return input without double quotes, words within double quotes and the
	 *         preceding keyword "at" if any
	 */
	public static String removeWordsWithinQuotes(String input) {
		input = cleanUp(input);

		int countDoubleQuotes = countNumberOfDoubleQuotes(input);
		Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
		Matcher m = p.matcher(input);

		if (countDoubleQuotes == 0) {
			return input;
		} else if (countDoubleQuotes == 2) {
			int startQuoteIndex = 0, endQuoteIndex = 0, count = 0;
			while (m.find()) {
				count++;
				if (count == 1) {
					startQuoteIndex = m.start();
				} else {
					assert count == 2;
					endQuoteIndex = m.start();
				}
			}
			String wordsWithinQuotes = input.substring(startQuoteIndex + 1,
					endQuoteIndex);
			String stringToRemove = Constants.DOUBLE_QUOTE + wordsWithinQuotes
					+ Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(startQuoteIndex, input).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemove = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemove;
			}
			return cleanUp(input.replaceAll(stringToRemove,
					Constants.EMPTY_STRING));
		} else {
			assert countDoubleQuotes == 4;
			int firstQuoteStart = 0, firstQuoteEnd = 0, secondQuoteStart = 0, secondQuoteEnd = 0, count = 0;
			while (m.find()) {
				count++;
				if (count == 1) {
					firstQuoteStart = m.start();
				} else if (count == 2) {
					firstQuoteEnd = m.start();
				} else if (count == 3) {
					secondQuoteStart = m.start();
				} else {
					assert count == 4;
					secondQuoteEnd = m.start();
				}
			}

			// first 2 double quotes
			String wordsWithinFirstQuotes = input.substring(
					firstQuoteStart + 1, firstQuoteEnd);
			String stringToRemoveFromFirstQuotes = Constants.DOUBLE_QUOTE
					+ wordsWithinFirstQuotes + Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(firstQuoteStart, input).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemoveFromFirstQuotes = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemoveFromFirstQuotes;
			}

			// next 2 double quotes
			String wordsWithinSecondQuotes = input.substring(
					secondQuoteStart + 1, secondQuoteEnd);
			String stringToRemoveFromSecondQuotes = Constants.DOUBLE_QUOTE
					+ wordsWithinSecondQuotes + Constants.DOUBLE_QUOTE;

			if (getWordBeforeQuote(secondQuoteStart, input).equalsIgnoreCase(
					Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT])) {
				stringToRemoveFromSecondQuotes = Constants.REGEX_AT_WITH_SPACES
						+ stringToRemoveFromSecondQuotes;
			}

			String temp = cleanUp(input.replaceAll(
					stringToRemoveFromFirstQuotes, Constants.EMPTY_STRING));
			temp = cleanUp(temp.replaceAll(stringToRemoveFromSecondQuotes,
					Constants.EMPTY_STRING));
			return temp;
		}
	}

	/**
	 * Returns the number of double quotes(") in the userInput
	 * 
	 * @param input
	 *            userInput
	 * @return number of double quotes(") in the userInput
	 */
	public static int countNumberOfDoubleQuotes(String input) {
		Pattern p = Pattern.compile(Constants.DOUBLE_QUOTE);
		Matcher m = p.matcher(input);

		int count = 0;
		while (m.find()) {
			count++;
		}
		return count;
	}

	/**
	 * Returns the word immediately before the quotation mark whose index is
	 * specified
	 * 
	 * @param indexQuote
	 *            index of quotation mark
	 * @param input
	 *            user input
	 * @return word immediately before the quotation mark. If there are no words
	 *         before the quotation mark, an empty string is returned.
	 */
	public static String getWordBeforeQuote(int indexQuote, String input) {
		String inputUntilQuote = cleanUp(input.substring(Constants.INDEX_BEGIN,
				indexQuote));
		return getLastWord(inputUntilQuote);
	}

	/**
	 * Returns the last word of a string
	 * 
	 * @param str
	 *            string whose last word is to be returned
	 * @return last word of the string
	 */
	public static String getLastWord(String str) {
		try {
			str = cleanUp(str);
			int indexOfLastSpace = str.lastIndexOf(Constants.SPACE_CHAR);

			if (indexOfLastSpace >= Constants.LIMIT_ZERO) {
				return str.substring(indexOfLastSpace).trim();
			} else {
				assert indexOfLastSpace == Constants.NOT_FOUND;
				return str;
			}
		} catch (Exception e) {
			return Constants.EMPTY_STRING;
		}
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\LOLParser.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\LOLParserTest.java
	 */


package parser;

import static org.junit.Assert.*;
import lol.Date;
import lol.Task;
import lol.Time;

import org.junit.Test;

public class LOLParserTest {

	@Test
	public void testGetCommandName() {
		assertEquals("add", LOLParser.getCommandName("add buy milk"));
		assertEquals("delete", LOLParser.getCommandName("delete 2"));
		assertEquals("edit", LOLParser.getCommandName("edit 5"));
		assertEquals("show", LOLParser.getCommandName("show"));
		assertEquals("undo", LOLParser.getCommandName("undo "));
	}

	@Test
	public void testGetTask() throws Exception {
		assertEquals(new Task("buy milk", null, new Date(14, 9)),
				LOLParser.getTask("add buy milk 14 sep"));
		assertEquals(new Task("buy milk", null, null),
				LOLParser.getTask("add buy milk"));
		assertEquals(null, LOLParser.getTask("add "));

		assertEquals(new Task("camp", "island", new Date(12, 12, 2014),
				new Date(15, 12, 2014)),
				LOLParser.getTask("add camp at island from 12-15 Dec"));
		assertEquals(new Task("camp", "island", new Date(12, 12, 2014),
				new Date(15, 12, 2014)),
				LOLParser.getTask("add camp at island from 12-15/12"));
		assertEquals(new Task("camp", "island", new Date(24, 11, 2014),
				new Date(2, 12, 2014)),
				LOLParser.getTask("add camp at island from 24 nov-2 dec"));
		assertEquals(new Task("camp", "island", new Date(24, 11, 2014),
				new Date(2, 12, 2014)),
				LOLParser.getTask("add camp at island from 24/11 to 2 dec"));
	}

	@Test
	public void testGetTaskIndex() {
		assertEquals(2, LOLParser.getTaskIndex("delete 2"));
		assertEquals(6, LOLParser.getTaskIndex("edit 6 send letter sat"));
		assertEquals(-1, LOLParser.getTaskIndex("delete tt"));
	}

	@Test
	public void testGetTaskIndexArray() {
		int[] arr = { 1, 2, 3 };
		int[] arr1 = { 2 };
		assertArrayEquals(arr, LOLParser.getTaskIndexArray("delete 1 2 3"));
		assertArrayEquals(arr, LOLParser.getTaskIndexArray(" done 1  2 3  "));
		assertArrayEquals(arr1, LOLParser.getTaskIndexArray("  rm   2  "));
		assertArrayEquals(null, LOLParser.getTaskIndexArray(" add task jjj"));
	}

	@Test
	public void testGetEditTask() throws Exception {
		assertEquals(new Task("buy milk", "supermarket", null),
				LOLParser.getEditTask("edit 6 at supermarket", new Task(
						"buy milk", null, null)));
		assertEquals(new Task("buy milk", "supermarket", null),
				LOLParser.getEditTask("edit 6 buy milk", new Task("buy juice",
						"supermarket", null)));
		assertEquals(new Task("buy milk", "supermarket", new Date(13, 11)),
				LOLParser.getEditTask("edit 6 13 nov", new Task("buy milk",
						"supermarket", null)));
		assertEquals(new Task("eat food", null, new Date(19, 10), new Time(
				"1800"), null), LOLParser.getEditTask("edit 2 6pm", new Task(
				"eat food", null, new Date(19, 10), new Time("1700"), null)));
		assertEquals(new Task("do something", "home", null),
				LOLParser.getEditTask("edit 2 at home rm date", new Task(
						"do something", null, new Date(1, 1, 15))));
	}

	@Test
	public void testGetDateForShowCommand() {
		assertEquals(new Date(20, 11),
				LOLParser.getDateForShowCommand("show 20/11/14"));
		assertEquals(null, LOLParser.getDateForShowCommand("show 20 novv"));
	}

	@Test
	public void testCountWords() {
		assertEquals(5, LOLParser.countWords("add on mon  do   something  "));
	}

	@Test
	public void testGetKeywordsForSearchCommand() {
		assertEquals("friends",
				LOLParser.getKeywordsForSearchCommand("search friends"));
		assertEquals("10 oct",
				LOLParser.getKeywordsForSearchCommand("search 10 oct"));
		assertEquals(
				"dinner with friends",
				LOLParser
						.getKeywordsForSearchCommand("search dinner with friends"));
		assertEquals(null, LOLParser.getKeywordsForSearchCommand("search"));
	}

	@Test
	public void testGetParameterInOriginalCase() {
		assertEquals("StuDy ProGRaMMiNg", LOLParser.getParameterInOriginalCase(
				"StuDy ProGRaMMiNg AT HoMe", "study programming"));
		assertEquals("HoMe", LOLParser.getParameterInOriginalCase(
				"StuDy ProGRaMMiNg AT HoMe", "home"));
		assertEquals("pIcNIc", LOLParser.getParameterInOriginalCase(
				"pIcNIc AT PicNic SPoT", "picnic"));
		assertEquals("PicNic SPoT", LOLParser.getParameterInOriginalCase(
				"pIcNIc AT PicNic SPoT", "picnic spot"));
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\LOLParserTest.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\TimeParser.java
	 */


/**
 * This class parses a string containing a time or time range.
 * The following formats of time are allowed: (not case-sensitive)
 * 
 * 12-hour format:
 * 2pm
 * 2.30pm
 * 
 * 24-hour format:
 * 0930
 * 
 * Time range (Space before and after 'to'):
 * 11am to 1 pm
 * 4pm to 6pm
 * 11 to 1pm
 * 4 to 6pm
 * 11am-1pm
 * 4pm-6pm
 * 11-1pm
 * 4-6pm
 * 
 */
package parser;

import java.util.Calendar;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lol.Constants;
import lol.Time;

public class TimeParser {
	/************* Attributes ***************/
	private String userInput;
	private String timeKeyword; // keyword preceding time - at, by, from or no
								// keyword

	/************* Constructors ***************/
	public TimeParser() {
		this(Constants.EMPTY_STRING);
	}

	public TimeParser(String userInput) {
		setUserInput(userInput);
		setTimeKeyword(Constants.EMPTY_STRING);
	}

	/************* Accessors ***************/
	public String getUserInput() {
		return userInput;
	}

	public String getTimeKeyword() {
		return timeKeyword;
	}

	/************* Mutators ***************/
	public void setUserInput(String userInput) {
		this.userInput = userInput.toLowerCase();
	}

	public void setTimeKeyword(String timeKeyword) {
		this.timeKeyword = timeKeyword.toLowerCase();
	}

	/************* Other methods ***************/

	/**
	 * Returns the start time of task in userInput
	 * 
	 * @return start of a task in userInput if it exists, else returns null
	 */
	public Time getStartTime() {
		cleanUp();
		DateParser dtp = new DateParser();

		// at
		Pattern pAt = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_AT]);
		Matcher mAt = pAt.matcher(getUserInput());

		while (mAt.find()) {
			String parameter = getParameterStartingAtIndex(mAt.end());
			if (isValidTimeFormat(parameter)) {
				setTimeKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT]);
				if (isTimeRange(parameter)) {
					return createStartTimeFromRange(parameter);
				} else if (is24hrTime(parameter)) {
					return new Time(parameter.trim());
				} else {
					assert is12hrTime(parameter);
					return create12hrTime(parameter);
				}
			}
		}

		// by
		Pattern pBy = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_BY]);
		Matcher mBy = pBy.matcher(getUserInput());

		while (mBy.find()) {
			String parameter = getParameterStartingAtIndex(mBy.end());
			if (isValidTimeFormat(parameter)) {
				setTimeKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_BY]);
				if (isTimeRange(parameter)) {
					return createStartTimeFromRange(parameter);
				} else if (is24hrTime(parameter)) {
					return new Time(parameter.trim());
				} else {
					assert is12hrTime(parameter);
					return create12hrTime(parameter);
				}
			}
		}

		// from
		Pattern pFrom = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_FROM]);
		Matcher mFrom = pFrom.matcher(getUserInput());

		while (mFrom.find()) {
			String parameter = getParameterStartingAtIndex(mFrom.end());
			if (isValidTimeFormat(parameter)) {
				setTimeKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_FROM]);
				if (isTimeRange(parameter)) {
					return createStartTimeFromRange(parameter);
				} else if (is24hrTime(parameter)) {
					return new Time(parameter.trim());
				} else {
					assert is12hrTime(parameter);
					return create12hrTime(parameter);
				}
			}
		}

		// no keyword
		String temp = getUserInput();
		String[] words = temp.split(Constants.SPACE);

		for (int i = 0; i < words.length; i++) {
			String word = words[i];
			if (isValidTimeFormat(word)) {
				if (isTimeRange(word)) {
					return createStartTimeFromRange(word);
				} else if (is24hrTime(word)) {
					// check if the word is both a year and 24hr time
					if (dtp.isBoth24hrTimeAndYear(word)) {
						// if it is meant to be a year, it should be preceded by
						// day and month
						if (i - 2 > 0
								&& dtp.isValidDateFormat(words[i - 2]
										+ Constants.SPACE + words[i - 1])) {
							continue;
						}
					}
					return new Time(word.trim());
				} else {
					assert is12hrTime(word);
					return create12hrTime(word);
				}
			}

			// find next 4 words because time formats can have at most
			// 5 words
			String[] nextWords = getNext4Words(words, i);

			if (hasTime(word, nextWords)) {
				Pattern p = Pattern.compile(word
						+ Constants.REGEX_ZERO_OR_MORE_SPACES + nextWords[0]);
				Matcher m = p.matcher(temp);

				if (m.find()) {
					String parameter = getParameterStartingAtIndex(m.start());
					if (isTimeRange(parameter)) {
						return createStartTimeFromRange(parameter);
					} else if (is24hrTime(parameter)) {
						return new Time(parameter.trim());
					} else {
						assert is12hrTime(parameter);
						return create12hrTime(parameter);
					}
				}
			}
		}
		return null;
	}

	/**
	 * Returns the end time of task in userInput
	 * 
	 * @return end of a task in userInput if it exists, else returns null
	 */
	public Time getEndTime() {
		cleanUp();

		// at
		Pattern pAt = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_AT]);
		Matcher mAt = pAt.matcher(getUserInput());

		while (mAt.find()) {
			String parameter = getParameterStartingAtIndex(mAt.end());
			if (isTimeRange(parameter)) {
				setTimeKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_AT]);
				return createEndTimeFromRange(parameter);
			}
		}

		// by
		Pattern pBy = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_BY]);
		Matcher mBy = pBy.matcher(getUserInput());

		while (mBy.find()) {
			String parameter = getParameterStartingAtIndex(mBy.end());
			if (isTimeRange(parameter)) {
				setTimeKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_BY]);
				return createEndTimeFromRange(parameter);
			}
		}

		// from
		Pattern pFrom = Pattern
				.compile(Constants.REGEX_KEYWORDS[Constants.INDEX_KEYWORD_FROM]);
		Matcher mFrom = pFrom.matcher(getUserInput());

		while (mFrom.find()) {
			String parameter = getParameterStartingAtIndex(mFrom.end());
			if (isTimeRange(parameter)) {
				setTimeKeyword(Constants.KEYWORDS[Constants.INDEX_KEYWORD_FROM]);
				return createEndTimeFromRange(parameter);
			}
		}

		// no keyword
		String temp = getUserInput();
		String[] words = temp.split(Constants.SPACE);

		for (int i = 0; i < words.length; i++) {
			String word = words[i];
			if (isTimeRange(word)) {
				return createEndTimeFromRange(word);
			}

			// find next 4 words because time formats can have at most
			// 5 words
			String[] nextWords = getNext4Words(words, i);

			if (hasTime(word, nextWords)) {
				Pattern p = Pattern.compile(Constants.REGEX_WORD_START + word
						+ Constants.REGEX_WORD_END);
				Matcher m = p.matcher(temp);

				if (m.find()) {
					String parameter = getParameterStartingAtIndex(m.start());
					if (isTimeRange(parameter)) {
						return createEndTimeFromRange(parameter);
					}
				}
			}
		}
		return null;
	}

	/**
	 * Returns the userInput without start time, end time, time range and
	 * keywords preceding that time. Example: if userInput is
	 * "add task on 6 oct 6-9pm", returns "add task on 6 oct"
	 * 
	 * @return userInput without time and keywords preceding that time
	 */
	public String getUserInputWithoutTime() {
		if (getStartTime() == null) {
			return getUserInput();
		}
		String keyword = getTimeKeyword();
		String time = Constants.EMPTY_STRING;

		if (keyword.isEmpty()) {
			String temp = getUserInput();

			String[] words = temp.split(Constants.SPACE);

			for (int i = 0; i < words.length; i++) {
				String word = words[i];
				if (isValidTimeFormat(word)) {
					time = word.trim();
					break;
				}

				// find next 4 words because time formats can have at most 5
				// words
				String[] nextWords = getNext4Words(words, i);

				if (hasTime(word, nextWords)) {
					Pattern p = Pattern.compile(word
							+ Constants.REGEX_ZERO_OR_MORE_SPACES
							+ nextWords[0]);
					Matcher m = p.matcher(temp);

					if (m.find()) {
						time = getParameterStartingAtIndex(m.start()).trim();
					}
					break;
				}
			}
		} else {
			Pattern p = Pattern.compile(Constants.REGEX_WORD_START + keyword
					+ Constants.REGEX_WORD_END);
			Matcher m = p.matcher(getUserInput());

			while (m.find()) {
				String parameter = getParameterStartingAtIndex(m.end());
				if (isValidTimeFormat(parameter)) {
					time = parameter.trim();
				}
			}
		}

		if (getTimeKeyword().isEmpty()) {
			return cleanUp(getUserInput().replaceAll(
					Constants.REGEX_WORD_START + time
							+ Constants.REGEX_WORD_END, Constants.SPACE));
		} else {
			return cleanUp(getUserInput().replaceAll(
					Constants.REGEX_WORD_START + keyword
							+ Constants.REGEX_WORD_END_1SPACE_WORD_START + time
							+ Constants.REGEX_WORD_END, Constants.SPACE));
		}
	}

	/**
	 * Checks whether a string is a valid time format
	 * 
	 * @param string
	 *            String to be checked
	 * @return true if string is a valid time format, else false
	 */
	public boolean isValidTimeFormat(String string) {
		return is12hrTime(string) || is24hrTime(string) || isTimeRange(string);
	}

	/**
	 * Checks whether a string represents time in 12-hour format, e.g. 2pm or
	 * 1.20am
	 * 
	 * @param string
	 *            String to be checked
	 * @return true if it represents 12-hour time, else false
	 */
	public boolean is12hrTime(String string) {
		try {
			string = string.trim();
			// Time format 1.30pm or 1 pm
			if ((string.endsWith(Constants.STRING_AM) || string
					.endsWith(Constants.STRING_PM))) {
				// extract time without am/pm
				String hourMin = string.substring(Constants.INDEX_BEGIN,
						string.length() - Constants.LENGTH_AM_PM).trim();
				return isTimeWithoutAmpm(hourMin);
			}
			return false;
		} catch (Exception e) {
			return false;
		}

	}

	/**
	 * Checks whether a string represents time in 24-hour format, e.g. 2359 or
	 * 1731
	 * 
	 * @param string
	 *            String to be checked
	 * @return true if it represents 24-hour time, else false
	 */
	public boolean is24hrTime(String string) {
		try {
			string = string.trim();
			if (string.length() != Constants.LENGTH_24HOUR_FORMAT) {
				return false;
			}

			int hour = Integer.parseInt(string.substring(Constants.INDEX_BEGIN,
					Constants.LENGTH_AM_PM));
			int min = Integer
					.parseInt(string.substring(Constants.LENGTH_AM_PM));
			return is24hrFormatInRange(hour, min);
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks whether a string contains a time range in the following formats:
	 * (Space before and after 'to') 11am to 1 pm, 4pm to 6pm, 11 to 1pm, 4 to
	 * 6pm, 11am-1pm, 4pm-6pm, 11-1pm, 4-6pm
	 * 
	 * @param string
	 *            string to be checked
	 * @return true if the string is a time range in any of the above formats,
	 *         else false
	 */
	public boolean isTimeRange(String string) {
		boolean containsSeparator = false;
		String[] times = {};

		try {
			if (string.contains(Constants.SEPARATOR_TO)) {
				times = string.split(Constants.SEPARATOR_TO);
				times = cleanUp(times);
				containsSeparator = true;
			} else if (string.contains(Constants.SEPARATOR_DASH)) {
				times = string.split(Constants.SEPARATOR_DASH);
				times = cleanUp(times);
				containsSeparator = true;
			}

			if (containsSeparator) {
				// 11am to 1pm, 4pm to 6pm, 11 to 1pm, 4 to 6pm
				if (times.length == Constants.LENGTH_TIME_RANGE) {
					return (is12hrTime(times[Constants.INDEX_START_TIME].trim()) && is12hrTime(times[Constants.INDEX_END_TIME]
							.trim()))
							|| (isTimeWithoutAmpm(times[Constants.INDEX_START_TIME]
									.trim()) && is12hrTime(times[Constants.INDEX_END_TIME]
									.trim()));
				}
			}
			return false;
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks whether a string represents time in 12-hour format without the
	 * suffix am/pm, e.g. 2 or 1.20
	 * 
	 * @param string
	 *            String to be checked
	 * @return true if it represents 12-hour time without am/pm suffix, else
	 *         false
	 */
	public boolean isTimeWithoutAmpm(String string) {
		string = string.trim();
		String[] splitHourMin = string.split(Constants.SEPARATOR_DOT);

		try {
			// e.g 1 or 1.30
			return (splitHourMin.length == Constants.LENGTH_HOUR && isHourInRange(splitHourMin[Constants.INDEX_HOUR]))
					|| (splitHourMin.length == Constants.LENGTH_HOUR_MINUTE
							&& isHourInRange(splitHourMin[Constants.INDEX_HOUR]) && isMinuteInRange(splitHourMin[Constants.INDEX_MINUTE]));
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks whether hour is between 1 and 12 (both inclusive)
	 * 
	 * @param hourStr
	 *            String to be checked
	 * @return true if hour is between 1 and 12 (both inclusive), else false
	 */
	public boolean isHourInRange(String hourStr) {
		int hour = Integer.parseInt(hourStr.trim());
		return (hour >= Constants.LIMIT_MIN_HR)
				&& (hour <= Constants.LIMIT_MAX_12HR);
	}

	/**
	 * Checks if minute is between 0 and 59 (both inclusive)
	 * 
	 * @param minuteStr
	 *            String to be checked
	 * @return true if minute is between 0 and 59 (both inclusive), else false
	 */
	public boolean isMinuteInRange(String minuteStr) {
		int minute = Integer.parseInt(minuteStr.trim());
		return (minute >= Constants.LIMIT_MIN_MINUTE)
				&& (minute <= Constants.LIMIT_MAX_MINUTE);
	}

	/**
	 * Checks if hour and minute are inside the 24hr format range i.e. hour is
	 * between 0 and 23 (inclusive) and minute is between 0 and 59 (inclusive)
	 * 
	 * @param hour
	 *            Hour
	 * @param min
	 *            Minute
	 * @return true if hour is between 0 and 23 (inclusive) and minute is
	 *         between 0 and 59 (inclusive), else false
	 */
	public boolean is24hrFormatInRange(int hour, int min) {
		return hour >= Constants.LIMIT_MIN_HR - 1
				&& hour <= Constants.LIMIT_MAX_24HR
				&& min >= Constants.LIMIT_MIN_MINUTE
				&& min <= Constants.LIMIT_MAX_MINUTE;
	}

	/**
	 * Given a string that represents 12hr time, creates a Time object
	 * Precondition: valid 12 hour format is passed as a parameter
	 * 
	 * @param string
	 *            time in 12-hour format, e.g 4pm or 6.20am
	 * @return Time object
	 */
	public Time create12hrTime(String string) {
		string = string.trim();
		if (!is12hrTime(string)) {
			return null;
		}

		try {
			String ampm = string.substring(string.length()
					- Constants.LENGTH_AM_PM);
			String hourMin = string.substring(Constants.INDEX_BEGIN,
					string.length() - Constants.LENGTH_AM_PM).trim(); // 1.30 or
																		// 1
			String[] splitHourMin = cleanUp(hourMin
					.split(Constants.SEPARATOR_DOT));

			if (splitHourMin.length == Constants.LENGTH_HOUR) {
				return new Time(
						Integer.parseInt(splitHourMin[Constants.INDEX_HOUR]),
						ampm);
			} else if (splitHourMin.length == Constants.LENGTH_HOUR_MINUTE) {
				return new Time(
						Integer.parseInt(splitHourMin[Constants.INDEX_HOUR]),
						Integer.parseInt(splitHourMin[Constants.INDEX_MINUTE]),
						ampm);
			}
		} catch (Exception e) {
			return null;
		}
		return null;
	}

	/**
	 * Given a string that represents a time range, creates a Time object of
	 * start time
	 * 
	 * @param string
	 *            time range in the following formats: 11am to 1 pm, 4pm to 6pm,
	 *            11 to 1pm, 4 to 6pm, 11am-1pm, 4pm-6pm, 11-1pm, 4-6pm
	 * @return start time as a Time object, null if invalid format
	 */
	public Time createStartTimeFromRange(String string) {
		string = string.trim();
		String[] times = {};

		try {
			if (!isTimeRange(string)) {
				return null;
			}
			if (string.contains(Constants.SEPARATOR_TO)) {
				times = cleanUp(string.split(Constants.SEPARATOR_TO));
			} else if (string.contains(Constants.SEPARATOR_DASH)) {
				times = cleanUp(string.split(Constants.SEPARATOR_DASH));
			} else {
				return null;
			}

			// 11am to 1pm, 4pm to 6pm
			if (is12hrTime(times[Constants.INDEX_START_TIME].trim())
					&& is12hrTime(times[Constants.INDEX_END_TIME].trim())) {
				return create12hrTime(times[Constants.INDEX_START_TIME]);
			}

			// 11 to 1pm, 4 to 6pm
			if (isTimeWithoutAmpm(times[Constants.INDEX_START_TIME].trim())
					&& is12hrTime(times[Constants.INDEX_END_TIME].trim())) {

				times[Constants.INDEX_END_TIME] = times[Constants.INDEX_END_TIME]
						.trim();
				String ampm = times[Constants.INDEX_END_TIME].substring(
						times[Constants.INDEX_END_TIME].length()
								- Constants.LENGTH_AM_PM).trim(); // suffix of
																	// end time

				String startTimeWithoutAmpm = times[Constants.INDEX_START_TIME]
						.trim();
				times[Constants.INDEX_END_TIME] = times[Constants.INDEX_END_TIME]
						.trim();
				String endTimeWithoutAmpm = times[Constants.INDEX_END_TIME]
						.substring(0, times[Constants.INDEX_END_TIME].length()
								- Constants.LENGTH_AM_PM);

				/*
				 * For 11-1pm, 10-2pm, the start-time ampm is the opposite of
				 * end-time ampm. However, for times after 12, e.g 12-2pm, do
				 * not toggle ampm. If end time is > 12 e.g. 10-12pm, then
				 * toggle.
				 */
				if ((Float.parseFloat(startTimeWithoutAmpm) >= Float
						.parseFloat(endTimeWithoutAmpm) && Float
						.parseFloat(startTimeWithoutAmpm) < Constants.LIMIT_MAX_12HR)
						|| (Float.parseFloat(endTimeWithoutAmpm) >= Constants.LIMIT_MAX_12HR)) {
					ampm = toggleAmPm(ampm);
				}
				return create12hrTime(startTimeWithoutAmpm + ampm);
			}
			return null;
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Given a string that represents a time range, creates a Time object of end
	 * time
	 * 
	 * @param string
	 *            time range in the following formats: 11am to 1 pm, 4pm to 6pm,
	 *            11 to 1pm, 4 to 6pm, 11am-1pm, 4pm-6pm, 11-1pm, 4-6pm
	 * @return end time as a Time object, null if invalid format
	 */
	public Time createEndTimeFromRange(String string) {
		string = string.trim();
		String[] times = {};

		try {
			if (!isTimeRange(string)) {
				return null;
			}
			if (string.contains(Constants.SEPARATOR_TO)) {
				times = string.split(Constants.SEPARATOR_TO);
			} else if (string.contains(Constants.SEPARATOR_DASH)) {
				times = string.split(Constants.SEPARATOR_DASH);
			} else {
				return null;
			}
			return create12hrTime(times[Constants.INDEX_END_TIME]);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns the opposite am/pm value of the parameter. If input is "am", it
	 * returns "pm" and vice-versa.
	 * 
	 * @param ampm
	 *            "am" or "pm"
	 * @return opposite value
	 */
	public String toggleAmPm(String ampm) {
		if (ampm.equalsIgnoreCase(Constants.STRING_AM)) {
			return Constants.STRING_PM;
		} else {
			return Constants.STRING_AM;
		}
	}

	/**
	 * Returns current time as a Time object
	 * 
	 * @return current time
	 */
	public Time getCurrentTime() {
		Calendar rightNow = Calendar.getInstance(); // Get the current date and
													// time
		int hour = rightNow.get(Calendar.HOUR);
		if (hour == 0) {
			hour = 12;
		}
		int minute = rightNow.get(Calendar.MINUTE);
		String ampm = rightNow.get(Calendar.AM_PM) == Calendar.AM ? Constants.STRING_AM
				: Constants.STRING_PM;

		return new Time(hour, minute, ampm);
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces
	 * 
	 * @param input
	 *            string to be cleaned up
	 * @return string without extra spaces
	 */
	public String cleanUp(String input) {
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		return input;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces for
	 * all strings in an array
	 * 
	 * @param input
	 *            array containing strings to be formatted
	 * @return array with formatted strings
	 */
	public String[] cleanUp(String[] input) {
		for (int i = 0; i < input.length; i++) {
			String temp = input[i];
			temp = temp.trim();
			temp = cleanUp(temp);
			input[i] = temp;
		}
		return input;
	}

	/**
	 * Removes multiple spaces between words, leading and trailing spaces in the
	 * userInput
	 * 
	 * @return string without extra spaces
	 */
	public String cleanUp() {
		String input = getUserInput();
		input = input.trim();
		input = input.replaceAll(Constants.REGEX_ONE_OR_MORE_SPACES,
				Constants.SPACE);
		setUserInput(input);
		return input;
	}

	/**
	 * Returns the Nth word of an input, where n starts from 1, e.g. 1 for 1st
	 * word
	 * 
	 * @param input
	 *            input string
	 * @param n
	 *            the index of word to return, starting from 1
	 * @return Nth word of input
	 */
	public String getNthWord(String input, int n) {
		input = cleanUp(input);
		String[] words = input.split(Constants.SPACE);
		if (words.length < n) {
			return Constants.EMPTY_STRING;
		} else {
			return words[n - 1];
		}
	}

	/**
	 * Returns a time starting from 'index' till the occurrence of another
	 * reserved word or the end of the string or another parameter, whichever is
	 * earlier
	 * 
	 * @param index
	 *            index of userInput at which the parameter to be returned
	 *            starts
	 * @return parameter starting from index
	 */
	public String getParameterStartingAtIndex(int index) {

		if (isIndexOutOfBounds(index)) {
			return null;
		}
		String parameter;
		int nextKeywordIndex = getIndexOfNextReservedWord(index + 1);
		if (nextKeywordIndex == Constants.NOT_FOUND) {
			parameter = getUserInput().substring(index).trim();
		} else {
			assert nextKeywordIndex > 0;
			parameter = getUserInput().substring(index, nextKeywordIndex)
					.trim();
		}
		// Check if the due date is followed by a description
		return removeDescriptionAfterTimeIfAny(parameter);

	}

	/**
	 * Removes task description after a time or time range, if any
	 * 
	 * @param time
	 *            String containing a time or time range which may or may not be
	 *            followed by a task description
	 * @return time or time range as a string
	 */
	public String removeDescriptionAfterTimeIfAny(String time) {
		String[] words = time.split(Constants.SPACE);
		String firstWord = words[Constants.INDEX_BEGIN];
		String[] nextWords = getNext4Words(words, Constants.INDEX_BEGIN);

		if (isValidTimeFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_5TH_WORD])) {
			return (firstWord + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE + nextWords[Constants.INDEX_5TH_WORD])
					.trim();
		} else if (isValidTimeFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_4TH_WORD])) {
			return (firstWord + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE + nextWords[Constants.INDEX_4TH_WORD])
					.trim();
		} else if (isValidTimeFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
				+ nextWords[Constants.INDEX_3RD_WORD])) {
			return (firstWord + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE + nextWords[Constants.INDEX_3RD_WORD])
					.trim();
		} else if (isValidTimeFormat(firstWord + Constants.SPACE
				+ nextWords[Constants.INDEX_2ND_WORD])) {
			return (firstWord + Constants.SPACE + nextWords[Constants.INDEX_2ND_WORD])
					.trim();
		} else if (isValidTimeFormat(firstWord)) {
			return firstWord.trim();
		} else {
			return time.trim();
		}
	}

	/**
	 * Returns the starting index of the next keyword
	 * 
	 * @param beginIndex
	 *            index of userInput to start searching from
	 * @return starting index of next keyword, -1 if not found
	 */
	public int getIndexOfNextReservedWord(int beginIndex) {
		String temp = getUserInput().substring(beginIndex);
		String[] words = temp.split(Constants.SPACE);
		int minIndex = Constants.NOT_FOUND;

		for (int i = 0; i < words.length; i++) {
			String word = words[i];
			String[] nextWords = getNext4Words(words, i);

			if (isReservedWord(word) || hasDate(word, nextWords)) {
				Pattern p = Pattern.compile(word
						+ Constants.REGEX_ZERO_OR_MORE_SPACES
						+ nextWords[Constants.INDEX_2ND_WORD]);
				Matcher m = p.matcher(temp);

				if (m.find()) {
					int keywordIndex = m.start() + beginIndex;
					if (minIndex == Constants.NOT_FOUND
							|| keywordIndex < minIndex) {
						minIndex = keywordIndex;
					}
				}
			}
		}
		return minIndex;
	}

	/**
	 * Checks whether the word and the next 4 words form a valid date
	 * 
	 * @param word
	 *            first word
	 * @param nextWords
	 *            second to fifth words, if there are less than 4 elements,
	 *            empty strings are entered for the array element
	 * @return true if word and nextWords contain a valid date, else false
	 */
	public boolean hasDate(String word, String[] nextWords) {
		DateParser dp = new DateParser();
		try {
			return dp.isValidDateFormat(word)
					|| dp.isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD])
					|| dp.isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD])
					|| dp.isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD])
					|| dp.isValidDateFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_5TH_WORD]);
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks whether the word and the next 4 words form a valid time or time
	 * range
	 * 
	 * @param word
	 *            first word
	 * @param nextWords
	 *            second to fifth words, if there are less than 4 elements,
	 *            empty strings are entered for the array element
	 * @return true if word and nextWords contain a valid time format, else
	 *         false
	 */
	public boolean hasTime(String word, String[] nextWords) {
		try {
			return isValidTimeFormat(word + Constants.SPACE
					+ nextWords[Constants.INDEX_2ND_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_3RD_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_4TH_WORD] + Constants.SPACE
					+ nextWords[Constants.INDEX_5TH_WORD])
					|| isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_4TH_WORD])
					|| isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD]
							+ Constants.SPACE
							+ nextWords[Constants.INDEX_3RD_WORD])
					|| isValidTimeFormat(word + Constants.SPACE
							+ nextWords[Constants.INDEX_2ND_WORD])
					|| isValidTimeFormat(word);
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Checks is a word is a keyword (at, by etc.) or reserved word (days of the
	 * week, today, tomorrow, tmw)
	 * 
	 * @param word
	 *            word to be checked
	 * @return true if a word is a keyword or reserved word, else false
	 */
	public boolean isReservedWord(String word) {
		return hasWordInDictionary(Constants.KEYWORDS, word)
				|| hasWordInDictionary(Constants.DAYS_IMMEDIATE, word)
				|| hasWordInDictionary(Constants.DAYS_LONG, word)
				|| hasWordInDictionary(Constants.DAYS_SHORT, word);
	}

	/**
	 * Checks whether index is out of bounds for userInput
	 * 
	 * @param index
	 *            index to be checked
	 * @return true if index out of bounds, else false
	 */
	public boolean isIndexOutOfBounds(int index) {
		return index < 0 || index >= getUserInput().length();
	}

	/**
	 * Check whether a word appears in a dictionary
	 * 
	 * @param dictionary
	 *            Dictionary to be searched
	 * @param word
	 *            Word to search for
	 * @return true if word appears in dictionary, false otherwise
	 */
	public boolean hasWordInDictionary(String[] dictionary, String word) {
		word = word.trim();
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(word)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Returns the next 4 words of userInput, starting from the index i + 1
	 * 
	 * @param words
	 *            Array of words in userInput
	 * @param i
	 *            The index of the first word
	 * @return The next 4 words after index i. If there are less than 4 words,
	 *         the empty words are represented by empty strings
	 */
	public String[] getNext4Words(String[] words, int i) {
		String[] nextWords = { Constants.EMPTY_STRING, Constants.EMPTY_STRING,
				Constants.EMPTY_STRING, Constants.EMPTY_STRING };

		if (i < words.length - 4) {
			int index = 0;
			while (index < 4) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 3) {
			int index = 0;
			while (index < 3) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 2) {
			int index = 0;
			while (index < 2) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else if (i < words.length - 1) {
			int index = 0;
			while (index < 1) {
				nextWords[index] = words[i + 1 + index];
				index++;
			}
		} else {
			assert i == words.length - 1;
		}
		return nextWords;
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\TimeParser.java





	/**
	 * origin: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\TimeParserTest.java
	 */


package parser;

import static org.junit.Assert.*;
import lol.Time;

import org.junit.Test;

public class TimeParserTest {
	@Test
	public void testGetUserInputWithoutTime() {
		TimeParser tp = new TimeParser(
				"add send letter at post office at 2.20am");
		assertEquals("add send letter at post office",
				tp.getUserInputWithoutTime());
		TimeParser tp1 = new TimeParser(
				" add   send letter  by 1800 at post  office on mon");
		assertEquals("add send letter at post office on mon",
				tp1.getUserInputWithoutTime());
		TimeParser tp2 = new TimeParser("add from 7pm meeting");
		assertEquals("add meeting", tp2.getUserInputWithoutTime());
		TimeParser tp3 = new TimeParser("add 4am do something");
		assertEquals("add do something", tp3.getUserInputWithoutTime());
		TimeParser tp4 = new TimeParser("add 11 meetings 11-4pm");
		assertEquals("add 11 meetings", tp4.getUserInputWithoutTime());
		TimeParser tp5 = new TimeParser("add something from 1 pm to 2 pm ");
		assertEquals("add something", tp5.getUserInputWithoutTime());
		TimeParser tp6 = new TimeParser("add something");
		assertEquals("add something", tp6.getUserInputWithoutTime());
		TimeParser tp7 = new TimeParser("add eat 3 pizzas at 3 pm");
		assertEquals("add eat 3 pizzas", tp7.getUserInputWithoutTime());
		TimeParser tp8 = new TimeParser("add eat 3 pizzas by 3 pm");
		assertEquals("add eat 3 pizzas", tp8.getUserInputWithoutTime());
		TimeParser tp9 = new TimeParser("add eat 3 pizzas 3 pm");
		assertEquals("add eat 3 pizzas", tp9.getUserInputWithoutTime());
		TimeParser tp10 = new TimeParser(
				"add watch at golden village today 6 pm to 8 pm");
		assertEquals("add watch at golden village today",
				tp10.getUserInputWithoutTime());
		TimeParser tp11 = new TimeParser(
				"add watch at golden village today 6 - 8 pm");
		assertEquals("add watch at golden village today",
				tp11.getUserInputWithoutTime());
		TimeParser tp12 = new TimeParser("add something at 9.09pm");
		assertEquals("add something", tp12.getUserInputWithoutTime());
	}

	@Test
	public void testGetStartTime() {
		TimeParser tp = new TimeParser(
				"add send letter at post office at 2.20am");
		assertEquals(new Time(2, 20, "am"), tp.getStartTime());
		TimeParser tp1 = new TimeParser(
				" add   send letter  by 1800 at post  office on mon");
		assertEquals(new Time(6, "pm"), tp1.getStartTime());
		TimeParser tp2 = new TimeParser("add from 7pm meeting");
		assertEquals(new Time("1900"), tp2.getStartTime());
		TimeParser tp3 = new TimeParser("add 4am do something");
		assertEquals(new Time(4, "am"), tp3.getStartTime());
		TimeParser tp4 = new TimeParser("add 11 meetings 11-4pm");
		assertEquals(new Time(11, "am"), tp4.getStartTime());
		TimeParser tp5 = new TimeParser("add something from 1 pm to 2 pm ");
		assertEquals(new Time("1300"), tp5.getStartTime());
		TimeParser tp9 = new TimeParser("add eat 3 pizzas 3 pm");
		assertEquals(new Time("1500"), tp9.getStartTime());
	}

	@Test
	public void testGetEndTime() {
		TimeParser tp2 = new TimeParser("add meeting 11pm");
		assertEquals(null, tp2.getEndTime());
		TimeParser tp3 = new TimeParser("add from 3-6pm do something");
		assertEquals(new Time(6, "pm"), tp3.getEndTime());
		TimeParser tp4 = new TimeParser("add meeting 11-4pm");
		assertEquals(new Time(4, "pm"), tp4.getEndTime());
		TimeParser tp5 = new TimeParser("add something from 1 pm to 2 pm ");
		assertEquals(new Time("1400"), tp5.getEndTime());
	}

	@Test
	public void testRemoveDescriptionAfterTimeIfAny() {
		TimeParser tp = new TimeParser();
		assertEquals("7am", tp.removeDescriptionAfterTimeIfAny("7am do this"));
		assertEquals("7 am", tp.removeDescriptionAfterTimeIfAny("7 am do this"));
		assertEquals("8 am - 9 am",
				tp.removeDescriptionAfterTimeIfAny("8 am - 9 am do this"));
	}

	@Test
	public void testHasTime() {
		TimeParser tp = new TimeParser();
		String[] nextWords = { "am", "to", "8", "am" };
		assertTrue(tp.hasTime("7", nextWords));
		String[] nextWords1 = { "", "", "", "" };
		assertTrue(tp.hasTime("7am", nextWords1));
		String[] nextWords2 = { "am", "", "", "" };
		assertTrue(tp.hasTime("7", nextWords2));
	}

	@Test
	public void testIs12hrTime() {
		TimeParser tp = new TimeParser();
		assertTrue(tp.is12hrTime("2pm"));
		assertTrue(tp.is12hrTime("2.30 am"));
		assertFalse(tp.is12hrTime("19.20am"));
	}

	@Test
	public void testIs24hrTime() {
		TimeParser tp = new TimeParser();
		assertTrue(tp.is24hrTime("0800"));
		assertTrue(tp.is24hrTime("2359"));
		assertFalse(tp.is24hrTime("9999"));
	}

	@Test
	public void testIsTimeRange() {
		TimeParser tp = new TimeParser();
		assertTrue(tp.isTimeRange("11-1pm"));
		assertTrue(tp.isTimeRange("11am-1pm"));
		assertTrue(tp.isTimeRange("4-6pm"));
		assertTrue(tp.isTimeRange("4pm-6pm"));
		assertTrue(tp.isTimeRange("11  to 1pm"));
		assertTrue(tp.isTimeRange("11am to 1pm"));
		assertTrue(tp.isTimeRange("4 to 6pm"));
		assertTrue(tp.isTimeRange("4pm to 6pm"));
		assertFalse(tp.isTimeRange("9999"));
	}

	@Test
	public void testIsTimeWithoutAmpm() {
		TimeParser tp = new TimeParser();
		assertTrue(tp.isTimeWithoutAmpm("11.30"));
		assertTrue(tp.isTimeWithoutAmpm("5"));
		assertFalse(tp.isTimeWithoutAmpm("5am"));
	}

	@Test
	public void testIsHourInRange() {
		TimeParser tp = new TimeParser();
		assertTrue(tp.isHourInRange("12"));
		assertTrue(tp.isHourInRange("4"));
		assertFalse(tp.isHourInRange("40"));
	}

	@Test
	public void testIsMinuteInRange() {
		TimeParser tp = new TimeParser();
		assertTrue(tp.isMinuteInRange("12"));
		assertTrue(tp.isMinuteInRange("0"));
		assertFalse(tp.isMinuteInRange("60"));
	}

	@Test
	public void testCreate12hrTime() {
		TimeParser tp = new TimeParser();
		assertEquals(new Time(10, 30, "am"), tp.create12hrTime("10.30am"));
		assertEquals(new Time(5, "pm"), tp.create12hrTime("5 pm"));
	}

	@Test
	public void testCreateStartTimeFromRange() {
		TimeParser tp = new TimeParser();
		assertEquals(new Time(10, 30, "am"),
				tp.createStartTimeFromRange("10.30-2pm"));
		assertEquals(new Time(5, "pm"),
				tp.createStartTimeFromRange("5pm to 9pm"));
		assertEquals(new Time(7, 40, "pm"),
				tp.createStartTimeFromRange("7.40-9pm"));
		assertEquals(new Time(3, 10, "am"),
				tp.createStartTimeFromRange("3.10 - 4 am"));
	}

	@Test
	public void testCreateEndTimeFromRange() {
		TimeParser tp = new TimeParser();
		assertEquals(new Time(2, "pm"), tp.createEndTimeFromRange("10.30-2pm"));
		assertEquals(new Time(9, 30, "pm"),
				tp.createEndTimeFromRange("5pm to 9.30pm"));
		assertEquals(new Time(9, "pm"), tp.createEndTimeFromRange("7.40-9pm"));
		assertEquals(new Time(4, "am"),
				tp.createEndTimeFromRange("3.10 - 4 am"));
	}

	/*
	 * @Test public void testGetCurrentTime() { TimeParser tp = new
	 * TimeParser(); assertEquals(new Time("1751"), tp.getCurrentTime()); }
	 */

	@Test
	public void testIsValidTimeFormat() {
		TimeParser tp = new TimeParser();

		/* This is an equivalence partition for a 12-hour time format */
		assertTrue(tp.isValidTimeFormat("2pm"));
		assertTrue(tp.isValidTimeFormat("2.30 am"));

		/* This is a boundary case for a 12-hour time format */
		assertTrue(tp.isValidTimeFormat("12.59 am"));
		assertFalse(tp.isValidTimeFormat("12.60 am"));

		/* This is an equivalence partition for a time range separated by hyphen */
		assertTrue(tp.isValidTimeFormat("4-6pm"));
		assertTrue(tp.isValidTimeFormat("4pm-6pm"));
		assertTrue(tp.isValidTimeFormat("6 am - 7 am"));

		/* This is an equivalence partition for a time range separated by "to" */
		assertTrue(tp.isValidTimeFormat("11  to 1pm"));
		assertTrue(tp.isValidTimeFormat("11am to 1pm"));
		assertTrue(tp.isValidTimeFormat("6  am to  7 am"));

		/* This is an equivalence partition for a 24-hour time format */
		assertTrue(tp.isValidTimeFormat("0800"));

		/* This is a boundary case for a 24-hour time format */
		assertTrue(tp.isValidTimeFormat("0000"));
		assertFalse(tp.isValidTimeFormat("2400"));
	}
}

	// End of segment: C:\Users\Rama\Documents\Repositories\Github\project\main\LifeOnLine\src\parser\TimeParserTest.java





